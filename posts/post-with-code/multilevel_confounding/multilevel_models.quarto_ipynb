{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Freedom, Hierarchies and Confounded Estimates\"\n",
        "date: \"2024-07-01\"\n",
        "categories: [\"TWFE\", \"mundlak\", \"hierarchical models\", \"DiD\"]\n",
        "keep-ipynb: true\n",
        "self-contained: true\n",
        "draft: false\n",
        "execute: \n",
        "  enabled: true\n",
        "jupyter: pymc_causal\n",
        "image: \"sky_castle.png\"\n",
        "author:\n",
        "    - url: https://nathanielf.github.io/\n",
        "    - affiliation: PyMC dev\n",
        "citation: true\n",
        "---"
      ],
      "id": "5b352ecf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "import bambi as bmb\n",
        "import pymc as pm\n",
        "import arviz as az\n",
        "import matplotlib.pyplot as plt\n",
        "from matplotlib import transforms\n",
        "from itertools import product\n",
        "import pyfixest as pf\n",
        "import statsmodels.formula.api as smf\n",
        "from patsy import dmatrices, dmatrix\n",
        "import seaborn as sns\n",
        "import networkx as nx\n",
        "from pyfixest.did.estimation import did2s, lpdid\n",
        "from matplotlib.lines import Line2D\n",
        "from matplotlib.patches import Patch\n",
        "import warnings\n",
        "warnings.simplefilter(action='ignore', category=FutureWarning)\n",
        "pd.options.mode.chained_assignment = None \n",
        "\n",
        "np.random.seed(100)\n"
      ],
      "id": "d43a9aec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "## Summary \n",
        "_Two Way Fixed Effects (TWFE) regression models are often used in Differences-in-Differences designs to estimate treatment effects while accounting for variation due to group effects in two dimensions. In recent years econometricians have discovered a number of issues with the TWFE estimator and provided clever diagnostics and corrections. Woolridge recently has shown that TWFE can be seen as a species of Mundlak regression offering further insight into the problem. We unpack what this means and what it suggests for model development in causal inference._\n",
        ":::\n",
        "\n",
        "# Architectures and Free Parameters\n",
        "\n",
        "> “There are no rules of architecture for a castle in the clouds.” - G.K. Chesterton\n",
        "\n",
        "Free choice is not whimsy or wanton action. Choice is free when taken within the confines of tolerable bounds. In statistical modelling we seek to discover what is plausibly realised within such bounds. We learn from the past to discern the shape of the processes which determine the future. Different models yield different insights into those structures which govern our trajectories. Which parameters are \"free\", and which are decisively characterised? Which realities are contestable and which non-negotiable? In this post we will dive into the way in which different inferential methodologies yield different insights into how group-level confounding constrains the realisations of our parameter space and shapes the architecture of causal inference.\n",
        "\n",
        "<img src=\"free_choice.png\" width=\"500\" height=\"300\" />\n",
        "\n",
        "Difference in Differences estimation is core a topic in contemporary social science and causal inference. It is a compelling methodology for licensing inferential statements about policy effects, but it is not a panacea. The method makes substantive assumptions about the treatment regime and the trends in the process before the treatment is introduced, but it also requires that the data is rich enough to mandate the intended interpretation of a heavily parameterised estimation model. The two-way fixed effects models attempt to tightly estimate the treatment effect by controlling for all sources of variation in our treatment due to group level factors in the DiD designs. These controls help isolate the variation due to actual treatment by pinning down the effects of interactions between treatment-units and time. We will see how these models and their intended interpretation come apart quickly in the face of staggered treatment roll-outs. We will also show how to fix these issues by enriching our regression specification. \n",
        "\n",
        "### Structure of the Presentation\n",
        "In this post we will structure the discussion as follows: \n",
        "\n",
        "- Estimation Strategies and Group Effects\n",
        "    - We go through a paired down parameter recovery examples of group-confounding and a range of estimation strategies aiming to account for group effect bias.\n",
        "- Nested Groups, Hierarchies and Fixed Effects\n",
        "    - We work through a real example of three-level group nesting; pupils in classes, in schools. Where we need to make decisions about the estimation strategy. \n",
        "- Two Way Fixed Effects and Temporal Confounding\n",
        "    - We branch off into examining an analogous case of confouning addressed in DiD designs. We show how TWFE works and how to specify these regression designs using Fixed Effects and Mundlak devices.\n",
        "- Issues with TWFE and Richly Parameterised Linear Models\n",
        "    - We examine the problems arising for the TWFE estimator in the case of staggered roll-outs. We also see how to address the issue with Mundlak devices, and reflect on what we've seen.\n",
        "    \n",
        "\n",
        "## Estimation Strategies and Group Effects\n",
        "\n",
        "First consider an estimation example due to Richard McElreath's [lecture series](https://www.youtube.com/playlist?list=PLDcUM9US4XdPz-KxHM4XHt7uUVGWWVSus) where we examine the various parameter recovery options available in the case of group level confounding. We want to move through these parameterisations to highlight the usefulness of Mundlak regressions. The source of these models is a paper Mundlak's 1978 paper _\"On the pooling of time series and cross section data\"_ in which he shows a method for adjusting for group-levels which proves to be a viable alternative to richly specified fixed effects model.\n",
        "\n",
        "First define a data generating process determined by group level effects:\n"
      ],
      "id": "dfda51a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def inv_logit(p):\n",
        "    return np.exp(p) / (1 + np.exp(p))\n",
        "\n",
        "N_groups = 30\n",
        "N_id = 3000\n",
        "a0 = -2\n",
        "bXY = 1\n",
        "bZY = -0.5\n",
        "g = np.random.choice(range(N_groups), size=N_id, replace=True)\n",
        "Ug = np.random.normal(1.5, size=N_groups)\n",
        "\n",
        "X = np.random.normal(Ug[g], size=N_id)\n",
        "Z = np.random.normal(size=N_groups)\n",
        "\n",
        "s = a0 + bXY*X + Ug[g] + bZY*Z[g]\n",
        "p = inv_logit(s)\n",
        "Y = np.random.binomial(n=1, p=p)\n",
        "\n",
        "\n",
        "sim_df = pd.DataFrame({'Y': Y, 'p': p, 's': s, 'g': g, 'X': X, 'Z': Z[g]})\n",
        "sim_df.head()"
      ],
      "id": "a1e54476",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This data generating process is characterised by the bernoulli outcome with group level confounds on the $X$ variable. If we model this relationship the confounding effects will bias naive parameter estimates on the covariates $X$, $Z$. We can imagine this is a class room setting with group-confounding due to teacher effects. In a DAG we see a picture something like this: \n"
      ],
      "id": "d954ff64"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "graph = nx.DiGraph()\n",
        "graph.add_edges_from([(\"classroom \\n G\", \"scores \\n y\"), (\"classroom \\n G\", \"student prep \\n X\"), (\"student prep \\n X\", \"scores \\n y\"), (\"class temp \\n Z\", \"scores \\n y\")])\n",
        "fig, ax = plt.subplots(figsize=(10,6))\n",
        "nx.draw_networkx(graph, arrows=True, ax=ax, \n",
        "node_size = 6000, font_color=\"whitesmoke\",pos={'classroom \\n G': [0, 0], 'scores \\n y': [0.5, 1], 'student prep \\n X': [0, 2], \n",
        "'class temp \\n Z': [1, 1]})\n",
        "ax.set_title(\"Group Confounding in a DAG\", fontsize=12);"
      ],
      "id": "dcacc3ad",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can plot the data here to visualise the shares of the binary outcomes. \n"
      ],
      "id": "c76852da"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g = sns.pairplot(sim_df[['Y', 'X', 'Z']], diag_kind=\"kde\", corner=True)\n",
        "g;"
      ],
      "id": "e634baef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We will see different estimation results as we explore different ways of parameterising the relationships, and the trade-offs for model specifications will become clearer.\n",
        "\n",
        "::: {.callout-warning title=\"Terminology Warning\"}\n",
        "There is a huge degree of confusion over the meaning of the terms \"Fixed Effects\" and \"Random Effects\". Within this blog post when we refer to __fixed effects__ we will mean the population level parameters. \n",
        " $$\\beta X$$ \n",
        " \n",
        "In contrast we will refer to group-level parameters $\\beta_{g}$\n",
        "\n",
        " $$\\Big(\\underbrace{\\beta}_{pop} + \\underbrace{\\beta_{g}}_{group}\\Big)X$$\n",
        " \n",
        "\n",
        "which are incorporated into our model equation modifying population level parameters as __random effects.__ We will generally use Wilkinson notation to specify these choices. Random effects for modifying a population parameter `X` are denoted with a conditional bar over the variable `( X | group)` and fixed effects are specified by just including the variable in the equation i.e. `y ~ X + (Z | group)` where X has a fixed effect parameterisation and Z a random effects parameterisation. We can also create indicator variables for group membership using this syntax with `y ~ C(group) + X + Z` where under the hood we pivot the group category into a zero-one variables indicating group membership. This parameterisation means each indicator variable (one for each level of the grouping variable) will receive a fixed effects population parameter.   \n",
        ":::\n",
        "\n",
        "### Naive Model\n",
        "\n",
        "We will use `Bambi` to specify the majority of these generalised linear models throughout this post. The formula syntax for `Bambi` enables us to specify generalised linear models with bernoulli outcomes. \n"
      ],
      "id": "95d34d07"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| \n",
        "naive_model = bmb.Model(f\"Y['>.5'] ~ X + Z \", sim_df, \n",
        "family=\"bernoulli\")\n",
        "naive_idata = naive_model.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True},)"
      ],
      "id": "d57a7976",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(naive_idata, var_names=['Intercept', 'X', 'Z'])"
      ],
      "id": "2089f9b0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we see that all three parameter estimates are biased away from their true values. Let's try a simple fixed effects approach that adds indicator variables for all but one of the group levels.  \n",
        "\n",
        "### Fixed Effects Model\n",
        "\n",
        "The additional syntax for creating the group level indicator variables is specified here. This will create a host of indicator variables for membership in each level of the group variable. \n"
      ],
      "id": "7639e831"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| \n",
        "fixed_effects_model = bmb.Model(f\"Y['>.5'] ~ C(g) + X + Z\", sim_df, \n",
        "family=\"bernoulli\")\n",
        "fixed_effects_idata = fixed_effects_model.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True},)"
      ],
      "id": "85ff8a45",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(fixed_effects_idata, var_names=['Intercept', 'X', 'Z'])"
      ],
      "id": "9f3d16f3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we see that the coefficient on the $X$ variable seems correct, but the coefficient on $Z$ is wildly wrong. Indeed the uncertainty interval on the $Z$ coefficient is huge. The fixed effect model was unable to learn anything about the correct parameter. Whereas the naive model seems to learn the correct $Z$ parameter but over estimates the $X$ coefficient. These are the kinds of trade-offs we need to be wary of as we account for the complexities of extensive group interactions in our model's functional form. \n"
      ],
      "id": "55e789bf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "fig, axs = plt.subplots(2, 1, figsize=(10, 9))\n",
        "axs = axs.flatten()\n",
        "\n",
        "az.plot_posterior(naive_idata, var_names=['X'], ax=axs[0], \n",
        "point_estimate=None,  hdi_prob='hide', color='red', label='Naive Model')\n",
        "axs[0].axvline(1, color='k')\n",
        "\n",
        "az.plot_posterior(fixed_effects_idata , var_names=['X'], ax=axs[0], point_estimate=None, hdi_prob='hide', label='Fixed Effect Models')\n",
        "axs[0].set_title(\"Naive/Fixed Model X Coefficient\")\n",
        "\n",
        "az.plot_posterior(naive_idata, var_names=['Z'], ax=axs[1], point_estimate=None,  hdi_prob='hide', color='red', ref_val_color='black')\n",
        "\n",
        "\n",
        "az.plot_posterior(fixed_effects_idata , var_names=['Z'], ax=axs[1], point_estimate=None, hdi_prob='hide')\n",
        "\n",
        "axs[1].set_title(\"Naive/Fixed Effect Model Z Coefficient\")\n",
        "axs[1].axvline(-0.5, color='k');\n"
      ],
      "id": "5bc137ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We now want to try another approach to handle to the group confounding that involves a hierarchical approach - adding group level effects to the population intercept term. \n",
        "\n",
        "### Multilevel Model\n",
        "\n",
        "The syntax for the random effects model is easily expressed in `bambi` too. These group level effects modify the intercept additively and are collectively drawn from a shared distribution implicit in the model. \n"
      ],
      "id": "53e2b29f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "multilevel_model = bmb.Model(f\"Y['>.5'] ~ (1 | g) + X + Z\", sim_df, \n",
        "family=\"bernoulli\")\n",
        "multilevel_model_idata = multilevel_model.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True},)"
      ],
      "id": "72082777",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This method posits a view that there is a shared underlying process generating each instance of group-behaviour i.e. the realised values of the outcome within each group. In the random effects multilevel model we replace the indivdual fixed effects indicator columns with additional parameters modifying the intercept term. This is the \"hierarchy\" or multi-level aspect of the specification.\n"
      ],
      "id": "7ac06937"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(multilevel_model_idata, var_names=['X', 'Z', 'Intercept'])"
      ],
      "id": "d86cf421",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next we'll apply the Mundlak device method which adds the group mean back to each observation as a single additional covariate. \n",
        "\n",
        "### Mundlak Model\n",
        "\n",
        "For this technique we augment the model by supplying group an additional column. This column records the group-level means of the \"confounded variable\" i.e. the variable which is realised under group level influences. Adding the group mean(s) to the model in this sense somewhat absolves of the requirement to include an extra multiplicity of parameters. It's more akin to feature creation than model specification, but it serves the same purpose - it accounts for group level variation and provides a mechanism for the model to learn the appropriate weights to accord each group in the final calculation. \n"
      ],
      "id": "4776e3ca"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "sim_df['group_mean'] = sim_df.groupby('g')['X'].transform(np.mean)\n",
        "\n",
        "sim_df['group_mean_Z'] = sim_df.groupby('g')['Z'].transform(np.mean)\n",
        "\n",
        "mundlak_model = bmb.Model(f\"Y['>.5'] ~ (1 | g) + X + Z + group_mean\", sim_df, \n",
        "family=\"bernoulli\")\n",
        "mundlak_idata = mundlak_model.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True},)"
      ],
      "id": "83d8f20a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Mundlak's insight is that this mechanism is akin to adding a whole slew of fixed-effect indicator variables for each group. It is a corrective mechanism for group confounding in our focal variable. We'll see how it allows for more flexible model specifications and has a role in making adjustments to aid identification in causal inference. \n"
      ],
      "id": "08fc9f61"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(mundlak_idata, var_names=['Intercept', 'X', 'Z'])"
      ],
      "id": "bc92454f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now plot all the parameter recovery models together and we'll see that there are some trade-offs between the fixed effects and random effects varieties of the modelling. \n",
        "\n",
        "### Plotting the Comparisons\n",
        "\n",
        "The parameter recovery exercise shows striking differences across each of the models \n"
      ],
      "id": "63c4c017"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "fig, axs = plt.subplots(3, 1, figsize=(10, 11))\n",
        "axs = axs.flatten()\n",
        "\n",
        "az.plot_posterior(naive_idata, var_names=['X'], ax=axs[0], \n",
        "point_estimate=None, color='red', label='Naive', hdi_prob='hide')\n",
        "axs[0].axvline(1, color='k', linestyle='--', label='True value')\n",
        "\n",
        "az.plot_posterior(fixed_effects_idata , var_names=['X'], ax=axs[0], point_estimate=None, hdi_prob='hide', label='Fixed')\n",
        "\n",
        "az.plot_posterior(multilevel_model_idata, var_names=['X'], ax=axs[0], point_estimate=None, hdi_prob='hide', color='green', label='Hierarchical')\n",
        "\n",
        "az.plot_posterior(mundlak_idata, var_names=['X'], ax=axs[0], point_estimate=None, hdi_prob='hide', color='purple', label='Mundlak')\n",
        "\n",
        "\n",
        "axs[0].set_title(\"X Coefficient\")\n",
        "\n",
        "az.plot_posterior(naive_idata, var_names=['Z'], ax=axs[1], point_estimate=None, hdi_prob='hide',  color='red', ref_val_color='black')\n",
        "\n",
        "\n",
        "az.plot_posterior(fixed_effects_idata , var_names=['Z'], ax=axs[1], point_estimate=None, hdi_prob='hide')\n",
        "\n",
        "az.plot_posterior(multilevel_model_idata, var_names=['Z'], ax=axs[1], point_estimate=None, hdi_prob='hide', color='green')\n",
        "\n",
        "az.plot_posterior(mundlak_idata, var_names=['Z'], ax=axs[1], point_estimate=None, hdi_prob='hide', color='purple')\n",
        "\n",
        "axs[1].set_title(\"Z Coefficient\")\n",
        "axs[1].axvline(-0.5, color='k', linestyle='--');\n",
        "\n",
        "az.plot_posterior(naive_idata, var_names=['Intercept'], ax=axs[2], point_estimate=None,  color='red', ref_val_color='black', hdi_prob='hide')\n",
        "\n",
        "\n",
        "az.plot_posterior(fixed_effects_idata , var_names=['Intercept'], ax=axs[2], point_estimate=None, hdi_prob='hide')\n",
        "\n",
        "az.plot_posterior(multilevel_model_idata, var_names=['Intercept'], ax=axs[2], point_estimate=None, hdi_prob='hide', color='green')\n",
        "\n",
        "az.plot_posterior(mundlak_idata, var_names=['Intercept'], ax=axs[2], point_estimate=None, hdi_prob='hide', color='purple')\n",
        "\n",
        "axs[2].axvline(-2, color='k', linestyle='--');"
      ],
      "id": "18345210",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Importantly, we see that while the fixed effects model is focused on recovering the treatment effect on the $X$ covariate, it does so somewhat at the expense of accuracy on the other systematic components of the model. This focus renders the model less predictively accurate. If we compare the models on the cross-validation score, we see how the hierarchical mundlak model is to be preferred.\n"
      ],
      "id": "67ca5907"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "compare_df = az.compare({'naive': naive_idata, 'fixed': fixed_effects_idata, 'hierarchical': multilevel_model_idata, \n",
        "'mundlak': mundlak_idata})\n",
        "compare_df"
      ],
      "id": "ab2ff4c6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.plot_compare(compare_df);"
      ],
      "id": "faba91fe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is not the only way to assess viability of the model's functional form but it's not a bad way.\n",
        "\n",
        "### Full Luxury Bayesian Mundlak Machine\n",
        "\n",
        "As good Bayesians we might be worry about the false precision of adding simple point estimates for the group mean covariates in the Mundlak model. We can remedy this by explicitly incorporating these values as an extra parameter and adding uncertainty to the draws on these parameters.  \n"
      ],
      "id": "422a7514"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "id_indx, unique_ids = pd.factorize(sim_df[\"g\"])\n",
        "\n",
        "coords = {'ids': list(range(N_groups))}\n",
        "with pm.Model(coords=coords) as model: \n",
        "\n",
        "    x_data = pm.Data('X_data', sim_df['X'])\n",
        "    z_data = pm.Data('Z_data', sim_df['Z'])\n",
        "    y_data = pm.Data('Y_data', sim_df['Y'])\n",
        "\n",
        "    alpha0 = pm.Normal('Intercept', 0, 1)\n",
        "    alpha_j = pm.Normal('alpha_j', 0, 1, dims='ids')\n",
        "    beta_xy = pm.Normal('X', 0, 1)\n",
        "    beta_zy = pm.Normal('Z', 0, 1)\n",
        "\n",
        "    group_means = pm.Normal('group_means', sim_df.groupby('g')['X'].mean().values, .1, dims='ids')\n",
        "    group_sigma = pm.HalfNormal('group_sigma', 0.1)\n",
        "    \n",
        "    group_mu = pm.Normal('group_mu', (group_means[id_indx]), group_sigma, observed=sim_df['X'].values)\n",
        "\n",
        "    mu = pm.Deterministic('mu', (alpha0 + alpha_j[id_indx]) + beta_xy*x_data + beta_zy*z_data + group_means[id_indx])\n",
        "    p = pm.Deterministic(\"p\", pm.math.invlogit(mu))\n",
        "    # likelihood\n",
        "    pm.Binomial(\"y\", n=1, p=p, observed=y_data)\n",
        "\n",
        "    idata = pm.sample(idata_kwargs={\"log_likelihood\": True})"
      ],
      "id": "caadd06d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Instead of merely adding a new feature to a regression we've added a second likelihood term for the predictor $X$ and seek to model this outcome as a function of the group means. In other words, we incorporate the idea that $X$ is confounded by some aspect of the group membership, and seek to estimate the nature of that confounding as it influences both the realisations of $X$ and $y$. Calibrating the `group_mean` parameter that is also included in our likelihood term for the $Y$ outcome. \n"
      ],
      "id": "7f196009"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pm.model_to_graphviz(model)"
      ],
      "id": "ee911748",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This model bakes more uncertainty into the process assuming a kind of measurement-error model, but again, the focus here is that we need to estimate a corrective adjustment factor for confounding effects that impact the estimation of impact due to our focal variable $X$. It's perhaps easier to see in this parameter recovery exercise than it is in real cases, but wherever we suspect plausible group level confounding you should consider Mundlak adjustments alongside your go-to fixed effects or random effects controls. \n"
      ],
      "id": "ca76699b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(idata, var_names=['Intercept', 'X', 'Z'])"
      ],
      "id": "71c4ff0f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "You can see it also recovers the correct parameter specifcation well. \n",
        "\n",
        "### Recap\n",
        "\n",
        "We've just seen a number of different modelling specifications that attempt to deal with the threat of group level confounding. Some varieties of model result in entirely saturated regression models with more parameters than observations. These models can quickly become unwieldy. We'll now look at a case-study where group level confounding remains highly plausible and the choice of estimation routine is not trivial. This will highlight aspects of how what we seek learn determines our model choice. \n",
        "\n",
        "## Nested Groups, Hierarchies and Fixed Effects\n",
        "\n",
        "We've seen how various attempts to account for the group effects can more or less recover the parameters of a complex data generating process with group confounding. Now we want to look at a case where we can have interacting group effects at multiple levels. \n",
        "\n",
        "![Structure](hierarchy.png)\n",
        "\n",
        "### Pupils within Class Rooms within Schools\n",
        "\n",
        "A natural three level group hierarchy occurs in the context of educational organisations and business org-charts. We can use this fact to interrogate briefly how inferential statements about treatment effects vary as a function of what and how we control for group level variation. We draw the following data set from _Linear Mixed Models: A Practical Guide Using Statistical Software_.\n"
      ],
      "id": "a8caf337"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df = pd.read_csv('classroom.csv')\n",
        "df['class_mean'] = df.groupby(['classid'])['mathprep'].transform(np.mean)\n",
        "df['school_mean'] = df.groupby(['schoolid'])['mathprep'].transform(np.mean)\n",
        "df.head()"
      ],
      "id": "c7f7b237",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The data has three distinct levels: (1) the child or pupil and their demographic attributes and outcome variable `mathgain`, (2) the classroom and the teacher level attributes such as their experience `yearstea` and a record of their mathematics courses taken `mathprep`, (3) school and neighbourhood level with features describing poverty measures in the vicinity `housepov`. \n",
        "\n",
        "We'll plot the child's outcome `mathgain` against the `mathprep` and distinguish the patterns by school.  \n"
      ],
      "id": "6a4140b5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "def rand_jitter(arr):\n",
        "    stdev = .01 * (max(arr) - min(arr))\n",
        "    return arr + np.random.randn(len(arr)) * stdev\n",
        "\n",
        "legend_elements = [Line2D([0], [0], marker='x', label='Minority', markerfacecolor='k'),\n",
        "                   Line2D([0], [0], marker='x', label='Minority + Poverty', markersize=14, markerfacecolor='k'), \n",
        "                   ]\n",
        "\n",
        "schools = df['schoolid'].unique()\n",
        "schools_10 = [schools[i:i+10] for i in range(0, len(schools), 10)]\n",
        "fig, axs = plt.subplots(3,4, figsize=(15, 13), \n",
        "sharey=True, sharex=True)\n",
        "axs = axs.flatten()\n",
        "mkr_dict = {1: 'x', 0: '+'}\n",
        "for s, ax in zip(schools_10, axs):\n",
        "    temp = df[df['schoolid'].isin(s)]\n",
        "    temp['m'] = temp['minority'].map(mkr_dict)\n",
        "    for m in temp['m'].unique():\n",
        "        temp1 = temp[temp['m'] == m]\n",
        "        ax.scatter(rand_jitter(temp1['mathprep']), \n",
        "        temp1['mathgain'], \n",
        "        c=temp1['schoolid'], cmap='tab10', \n",
        "        s=temp1['housepov']*100, \n",
        "        marker = m)\n",
        "    ax.set_title(f\"Schools \\n {s}\");\n",
        "    ax.set_xlabel(\"MathPrep\")\n",
        "    ax.set_ylabel(\"MathGain\")\n",
        "\n",
        "axs[0].legend(handles=legend_elements);\n"
      ],
      "id": "dbaf767c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We've plotted here the individual student outcomes. We've sized the dots by the poverty in their neighbourhoods and differentiated the markers by whether the student was in minority group. There are, in short, reasons here to worry about group-level confounding. There is a small number of observed students per school so the individual school level distributions show some extreme outliers but the overall distribution nicely converges to an approximately normal symmetric shape.\n"
      ],
      "id": "f1af4e62"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, axs = plt.subplots(1, 2, figsize=(10, 6))\n",
        "axs = axs.flatten()\n",
        "for school in schools:\n",
        "    temp = df[df['schoolid'] ==school]\n",
        "    axs[0].hist(temp['mathgain'], color='grey', alpha=0.3, density=True, histtype='step', cumulative=True)\n",
        "\n",
        "axs[0].hist(df['mathgain'], bins=30, ec='black', density=True, cumulative=True, histtype='step')\n",
        "axs[1].hist(df['mathgain'], bins=30, ec='black', density=True, cumulative=False)\n",
        "axs[0].set_title(\"Cumulative Distribution Function by School\")\n",
        "axs[1].set_title(\"Overall Distribution\");"
      ],
      "id": "da1413cd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With these kinds of structures we need to be careful in how we evaluate any treatment effects when there are reasons to believe in group-level effects that impact the outcome variable. Imagine the true treatment effect is a sprinter running too fast to cleanly measure - each group interaction effect is added to his load as a weight. Enough weights absorb enough of the variation in the treatment that he is dragged to a crawl. Whatever movement he can make while dragging this burden is the effect we attribute to the treatment. Or put another way - the effects of various group interactions will modify the treatment effectiveness in some way and unless we account for this impact in our model, then the inferences regarding the treatment will be clouded. \n",
        "\n",
        "### Interaction Effects and Nuisance Parameters\n",
        "\n",
        "Not all possible interactions will be present in the data. But if we specify the model to account for various interactions we may explode the number of parameters beyond the number of data points. This can cause issues in estimation routines and requires consideration about what the group parameters are aimed at capturing. \n",
        "\n",
        "Why add covariates for group-membership when no observation reflects outcomes in that group? We cannot learn anything about these cases. At least if we add the group effects as a hierarchical random effect we induce shrinkage on the parameter estimates towards the mean of the hierarchical parameter in the model. This means that when predicting on \"new\" data with examples of these missing cases we can predict a sensible default. The distinction rests in the role we have in mind for these tools. If we seriously commit to the idea that group variation reflects a real \"common\" process in the larger population and we want to learn about that over-arching process then we deploy a random effects model. But if we only see these as tools for accounting to variation in the sample, allowing us to pin down an alternative focal estimate then the group indicator covariates are just \"nuisance\" parameters and missing cases are irrelevant.  \n",
        "\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Philosophical Digression\n",
        "This last point skips a little quickly over a fundamental feature of interpreting these models. If we aim to interpret these models as reflecting a common process across these groups that exists in a \"population\", then we're endorsing an inferential view that extends beyond the sample. We're actively seeking to learn a general truth about the data generating process which we deem to be adequately expressed in our model. If we seek to \"soak up\" the variation due to group effects, we're treating these group effects as noise in the sample data and making inferential commitments only about the focal parameter in the model. This approach to learning differentiates approaches to credible causal inference. On the one hand, fixing your estimand and designing estimators to specifically capture that estimate seems like a modest and compelling strategy. On the other hand if your model ignores aspects of underlying phenomena or fails to retrodict the observable data, it's dubious as to why anyone would trust its output. \n",
        ":::\n",
        "\n",
        "\n",
        "To see the extent of redundany we can examine the dimensions of the covariate matrices that result from including more or less interaction terms. \n"
      ],
      "id": "3564480c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "y, X = dmatrices(\"mathgain ~ mathprep + C(schoolid)+ C(classid)\", df, return_type=\"dataframe\")\n",
        "print(X.shape)\n",
        "\n",
        "y, X1 = dmatrices(\"mathgain ~ mathprep + C(schoolid)/C(classid)\", df, return_type=\"dataframe\")\n",
        "print(X1.shape)\n",
        "\n",
        "\n",
        "y, X2 = dmatrices(\"mathgain ~ mathprep + C(schoolid):C(childid)\", df, return_type=\"dataframe\")\n",
        "print(X2.shape)"
      ],
      "id": "02cfca21",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We see here how different ways in which to account for group level variation and interaction effects lead to vastly inflated feature matrices. However not all interaction terms matter, or put another way... nor all the possible interactions feature in the data. So we have likely inflated the data matrix beyond necessity. \n",
        "\n",
        "Here we define a helper function to parse a complex interaction formula, remove the columns entirely composed of zeros and return a new formula and dataframe which has a suitable range of features to capture the variation structures in the data. \n"
      ],
      "id": "21e1ac84"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def make_interactions_df(formula, df):\n",
        "    y, X = dmatrices(formula, df, return_type=\"dataframe\")\n",
        "    n = X.shape[1]\n",
        "    X = X[X.columns[~(np.abs(X) < 1e-12).all()]]\n",
        "    n1 = X.shape[1]\n",
        "    target_name = y.columns[0]\n",
        "    d = pd.concat([y, X], axis=1)\n",
        "    d.drop(['Intercept'], axis=1, inplace=True)\n",
        "    d.columns = [c.replace('[', '').replace(']','').replace('C(', '').replace(')', '').replace('.', '_').replace(':', '_') for c in d.columns]\n",
        "    cols = ' + '.join([col for col in d.columns if col != target_name])\n",
        "    formula = f\"{target_name} ~ {cols}\"\n",
        "    print(f\"\"\"Size of original interaction features: {n} \\nSize of reduced feature set: {n1}\"\"\")\n",
        "    return formula, d\n",
        "\n",
        "formula, interaction_df = make_interactions_df(\"mathgain ~ mathprep + C(schoolid):C(childid)\", df)\n",
        "\n",
        "interaction_df.head()"
      ],
      "id": "5166fe82",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We have reduced the number of interactions by an order of magnitude! We can now fit a regression model to the revised feature matrix. \n",
        "\n",
        "### Comparing Interaction Models\n",
        "\n",
        "Consider the variation in the coefficient values estimated for `mathprep` as we add more and more interaction effects. The addition of interaction effects generates a large number of completely 0 interaction terms which we remove here. \n"
      ],
      "id": "7d855d0d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "formulas = [\"\"\"mathgain ~ mathprep + C(schoolid)\"\"\",\n",
        "\"\"\" mathgain ~ mathprep + school_mean*class_mean\"\"\" , \n",
        "\"\"\" mathgain ~ mathprep + mathkind + sex + school_mean*class_mean\"\"\" , \n",
        "\"\"\"mathgain ~ mathprep + C(schoolid) + C(classid)\"\"\", \n",
        "\"\"\"mathgain ~ mathprep + C(schoolid)*C(classid)\"\"\",\n",
        "\"\"\"mathgain ~ mathprep + C(classid):C(childid)\"\"\", \n",
        "]\n",
        "\n",
        "estimates_df = []\n",
        "for f in formulas:\n",
        "    formula, interaction_df = make_interactions_df(f, df)\n",
        "    result = smf.ols(formula, interaction_df).fit()\n",
        "    estimates = [[result.params['mathprep']], list(result.conf_int().loc['mathprep', :]), [formula]]\n",
        "    estimates = [e for est in estimates for e in est]\n",
        "    estimates_df.append(estimates)\n",
        "\n",
        "estimates_df = pd.DataFrame(estimates_df, columns=['mathprep_estimate', 'lower bound', 'upper bound', 'formula'])\n",
        "\n",
        "estimates_df"
      ],
      "id": "dc17d72f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The point here (perhap obvious) is that the estimate of treatment effects due to some policy or programme can be differently understood when the regression model is able to account for increasing aspects of individual variation. Choice of the __right__ way to \"saturate\" your regression specification are at the heart of causal inference. The right control structures determine the freedom available to vary your focal treatment effect parameter. \n",
        "\n",
        "We will consider a number of specifications below that incorporate these group effects in a hierarchical model which nests the effect of class-membership within school membership. This choice allows us to control for group specific interactions without worrying about over-indexing on the observed interaction effects in the sample data requiring that we handle more fixed effects parameters than we have data points. \n",
        "\n",
        "In what follows we'll specify a nested approach to the parameter specifcation using a random effects model. The idea here is that classes are already implicitly nested in schools and so we don't need to add parameters for classes at multiple schools. Additionally we're positing that there is independent interest in the effectiveness school/class effects i.e. the degree to which variation in a school/class nest can account for variation in the outcome. \n",
        "\n",
        "#### Minimal Model\n"
      ],
      "id": "7c02d2c6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| \n",
        "model = bmb.Model(f\"mathgain ~ mathprep + (1 | schoolid / classid)\", df)\n",
        "idata = model.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})"
      ],
      "id": "ecead68f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The model specification here is deliberately minimalist we want to observe how much of the variation in the outcome can be accounted for by solely adding extensive controls for interactions of group level effects and the treatment but ignoring all else. \n"
      ],
      "id": "e41ddc87"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model.graph()"
      ],
      "id": "e32a780a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can see the derived sigma parameters here which can be understood as partialling out the variance of the outcome into components due to those group level effects and the unexplained residuals. \n"
      ],
      "id": "dc1b36ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(idata, var_names=['Intercept', '1|schoolid_sigma', '1|schoolid:classid_sigma', 'mathgain_sigma', 'mathprep'])\n"
      ],
      "id": "a61c1c6e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note here the relative proportion of the school specifc variances `1|schoolid_sigma` to the overall variance of the residuals `mathgain_sigma`.\n",
        "\n",
        "### Calculating the IntraClass Correlation Coefficient\n",
        "\n",
        "These models faciliate the calculation of the ICC statistics which is a measure of \"explained variance\". The thought is to gauge the proportion of variance ascribed to one set of random effects over and above the total estimated variance in the baseline model, including the residuals `mathgain_sigma`.\n"
      ],
      "id": "ecf9af57"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "a = idata['posterior']['1|schoolid_sigma']**2\n",
        "\n",
        "b = (idata['posterior']['1|schoolid:classid_sigma']**2 + idata['posterior']['1|schoolid_sigma']**2)\n",
        "\n",
        "c = (idata['posterior']['1|schoolid:classid_sigma']**2 + idata['posterior']['1|schoolid_sigma']**2 + idata['posterior']['mathgain_sigma']**2)\n",
        "\n",
        "(a / c).mean().item() \n"
      ],
      "id": "eff2b7a3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "((a + b) / c).mean().item()"
      ],
      "id": "5393b1a0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can see here that the interaction terms do seem to account for a goodly portion of the variance in the outcome and we ought to consider retaining their inclusion in our modelling work. The structure of the problem drives us towards their inclusion. Class/school effects are going to absorb a sufficient portion of the variation. So they merit study in their own right, lest the individual class/school dynamics obscure the effectiveness of the `mathprep` treatment. Similarly, it's likely valuable to consider the efficacy of the average class/school in a wider policy conversation. \n",
        "\n",
        "### Augmenting the Models\n",
        "\n",
        "Next we augment our model with more pupil level control variables aiming to pin down some of the aspects of the variation in the outcome. \n",
        "\n",
        "#### Adding Pupil Fixed Effects\n",
        "Here we add these fixed effects population parameters. But note they are not merely devices for controlling variance in the outcome, they're interpretation is likely of independent interest. \n"
      ],
      "id": "96c1c62c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "model_fixed = bmb.Model(f\"mathgain ~  sex + minority + ses + mathprep + (1 | schoolid / classid)\", df)\n",
        "idata_fixed = model_fixed.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})"
      ],
      "id": "e182ee03",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(idata_fixed, var_names=['Intercept', 'sex', 'minority', 'ses', 'mathprep',\n",
        "'1|schoolid_sigma', '1|schoolid:classid_sigma', 'mathgain_sigma'])"
      ],
      "id": "abba242a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we add a further class level control. \n",
        "\n",
        "#### Adding More Class and Pupil Level Fixed Effects\n"
      ],
      "id": "ccfed447"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "model_fixed_1 = bmb.Model(f\"mathgain ~ mathkind + sex + minority + ses + yearstea +\tmathknow + mathprep + (1 | schoolid / classid)\", df.dropna())\n",
        "idata_fixed_1 = model_fixed_1.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})"
      ],
      "id": "2077a9a2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(idata_fixed_1, var_names=['Intercept', \n",
        "'mathkind', 'sex', 'minority', 'ses', 'yearstea', 'mathknow', 'mathprep','1|schoolid_sigma', '1|schoolid:classid_sigma', 'mathgain_sigma'])"
      ],
      "id": "b341e6fd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, ax = plt.subplots(figsize=(10, 7))\n",
        "az.plot_forest([idata, idata_fixed, idata_fixed_1], combined=True, var_names=['mathprep', '1|schoolid_sigma', '1|schoolid:classid_sigma', 'mathgain_sigma'], ax=ax)\n",
        "ax.axvline(1)"
      ],
      "id": "193b359f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We now make use of `bambi`s model interpretation module to plot the marginal effect on the outcome due to changes in the treatment intensity. \n"
      ],
      "id": "a6f068f5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "fig, axs = plt.subplots(1, 3, figsize=(20, 6), \n",
        "dpi=120, sharey=True, sharex=True)\n",
        "axs = axs.flatten()\n",
        "axs[0].axhline(50, color='red', label='Reference Line', \n",
        "linestyle='--')\n",
        "axs[1].axhline(50, color='red', label='Reference Line', \n",
        "linestyle='--')\n",
        "axs[2].axhline(50, color='red', label='Reference Line', \n",
        "linestyle='--')\n",
        "bmb.interpret.plot_predictions(model, idata, \"mathprep\", ax=axs[0]);\n",
        "bmb.interpret.plot_predictions(model_fixed, idata_fixed, \"mathprep\", ax=axs[1]);\n",
        "bmb.interpret.plot_predictions(model_fixed_1, idata_fixed_1, \"mathprep\", ax=axs[2]);\n",
        "axs[0].set_title(\"Variation in Implied Outcome by Treatment \\n mathgain ~ mathprep + (1 | schoolid / classid) \")\n",
        "axs[1].set_title(\"Variation in Implied Outcome by Treatment \\n mathgain ~ sex + minority + ses + mathprep + (1 | schoolid / classid) \")\n",
        "axs[2].set_title(\"Variation in Implied Outcome by Treatment \\n mathgain ~ mathkind + sex + minority + ses + yearstea + \\n mathknow + mathprep + (1 | schoolid / classid\")\n",
        "axs[0].set_xlabel('')\n",
        "axs[1].set_xlabel('')\n",
        "axs[0].legend();\n"
      ],
      "id": "059ba439",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As we can see here across all the different model specifications we see quite modest effects of treatment with very wide uncertainty. You might therefore be sceptical that teacher training has any real discernible impact on child outcomes? Maybe you believe other interventions are more important to fund? These kinds of questions determine policy. So misguided policy interventions on child-hood education can have radical consequences. It's, therefore, vital that we have robust and justifiable approaches and tooling for the analysis of these policy questions in the face of group level confounding. \n",
        "\n",
        "This last point is crucial - when model complexity balloons due extensive interaction effects, then we need efficient tools to interrogate the outcome level differences implied by the model choices. Your intuition and understanding of a process is keyed to the observable effects of that process. Your understanding of the internal mechanics of a model is likely less than your concrete expectations of observable behaviour. As such, credibility requires that we be able to assess models on the variation produced in the outcome variable rather merely on the parameters values. \n",
        "\n",
        "## Two Way Fixed Effects and Temporal Confounding\n",
        "\n",
        "Difference in Differences designs are the overworked donkeys of social science. Many, many studies stand or fall by the assumptions baked into DiD designs. There are at least two aspects to these assumptions (i) the substantive commitments about the data generating process (e.g. parrallel trends) and (ii) the appropriateness of the functional form used to model (i). We will look first at a case where all the assumptions can be met, and then examine how things break-down under challenging staggered treatment regimes. \n",
        "\n",
        "### Event Studies and Change in Time\n",
        "\n",
        "Event studies or dynamic treatment effects are an approach to measuring the gradual treatment effect as it evolves in time. We take this panel data set from the `pyfixest` package to demonstrate. \n"
      ],
      "id": "615b7598"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "url = \"https://raw.githubusercontent.com/py-econometrics/pyfixest/master/pyfixest/did/data/df_het.csv\"\n",
        "df_het = pd.read_csv(url)\n",
        "df_het.head()"
      ],
      "id": "25adcdd9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Panel data of this kind of structure is difficult to intuit unless visualised. The key structures on which this DiD estimator works are the averages across state and time. We depict these here. Note how we define a causal contrast as the difference between the treated and control groups averages over time. In particular our estimator has to account for the fact that we have a \"dynamic\" control group. As each cohort is treated our treatment group expands and the causal contrast of interest is differently defined. To gain a view of the time-evolution of treatment we want to marginalise over the specifc cohorts and extract a view of the how the effects evolve after the introduction of the treatment in expectation. \n"
      ],
      "id": "5b76d0fb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| \n",
        "fig, axs = plt.subplots(2, 1, figsize=(10, 12))\n",
        "axs = axs.flatten()\n",
        "for u in df_het['unit'].unique():\n",
        "    temp = df_het[df_het['unit']==u]\n",
        "    axs[0].plot(temp['year'], temp['dep_var'], color='grey', alpha=0.01)\n",
        "    axs[1].plot(temp['year'], temp['dep_var'], color='grey', alpha=0.01)\n",
        "df_het.groupby(['year', 'state'])[['dep_var']].mean().reset_index().pivot(index='year', columns='state', values='dep_var').plot(ax=axs[0], legend=False, color='blue', \n",
        "alpha=0.4)\n",
        "\n",
        "df_het.groupby(['year', 'g'])[['dep_var']].mean().reset_index().pivot(index='year', columns='g', values='dep_var').plot(ax=axs[1], legend=False)\n",
        "\n",
        "axs[0].set_title(\"Difference in Differences \\n State Mean Change an Individual Trajectories\")\n",
        "axs[1].set_title(\"Difference in Differences \\n Mean Change an Individual Trajectories\");"
      ],
      "id": "59ae7396",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note how the blue line represents a cohort that never undergoes a treatment and is maintained as a coherent control group throughout the sequence even though we have two other cohorts. This ensures we have a constant contrast case allowing us to identify the causal estimand of interest. It's also worth calling out that we have heterogenous patterns in the treatment effects across the cohorts i.e. the the intensity of the treatment effect differs across the cohorts. We'll apply the vanilla TWFE estimator and then dig into how it works.\n",
        "\n",
        "### TWFE in `pyfixest`\n",
        "\n",
        "A natural question is to wonder how the treatment effect evolves over time? How does policy shift behaviours? Is it initially impactful converging to a quick plateau or a slowly building pattern of consistent growth?\n"
      ],
      "id": "d2caa442"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fit_twfe_event = pf.feols(\n",
        "    \"dep_var ~ i(rel_year, ref=-1.0) | state + year \",\n",
        "    df_het,\n",
        "    vcov={\"CRV1\": \"state\"},\n",
        ")\n",
        "\n",
        "fit_twfe_event.tidy()"
      ],
      "id": "863f15b5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The model specification defines indicator variables for the relative years before and after the penultimate year before treatment is applied, it then  incorporates the fixed effects for state and year. The coefficient values ascribed the the relative year indicators are used to plot the event-study trajectories. This is a two-way fixed effects estimation routine where the fixed effects for state and year indicators absorb the variance due to those groupings. It is often estimated using a de-meaning technique which we will demonstrate below.\n"
      ],
      "id": "f977c927"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "figsize = [1200, 600]\n",
        "fit_twfe_event.iplot(\n",
        "    coord_flip=False,\n",
        "    title=\"TWFE-Estimator\",\n",
        "    figsize=figsize,\n",
        "    xintercept=18.5,\n",
        "    yintercept=0,\n",
        ").show()\n"
      ],
      "id": "c3a0e35a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can also aim to marginalise over the details of the temporal trajectories by defining the similar estimation routine on the individuals and their treatment indicator.\n"
      ],
      "id": "120e70d1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fit_twfe = pf.feols(\n",
        "    \"dep_var ~ i(treat) | unit + year\",\n",
        "    df_het,\n",
        "    vcov={\"CRV1\": \"state\"},\n",
        ")\n",
        "\n",
        "fit_twfe.tidy()\n"
      ],
      "id": "aaa0ad12",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### De-meaning and TWFEs\n",
        "\n",
        "We've seen above that the fixed-effect estimators in these DiD designs involve a lot of indicator variables. These are largely not the focus on the question at hand but are used exlusively to absorb the noise that takes away from our understanding of the treatment effect. We can achieve similar results with less parameters required if we \"de-mean\" the focus variables by the group averages of the control factors of `state` and `year` or `unit`. This operation makes for more efficient TWFE estimation routines is [provably](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3906345) a variety of mundlak regression as shown by Woolridge 2021. \n",
        "\n",
        "We implement the de-meaning technique and show \"equivalence by python\" as follows:"
      ],
      "id": "4305c9aa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def demean(df, col_to_demean, group):\n",
        "    return df.assign(**{col_to_demean: (df[col_to_demean]\n",
        "                                        - df.groupby(group)[col_to_demean].transform(\"mean\")\n",
        "                                        )})\n",
        "\n",
        "\n",
        "def apply_demeaning(df_het, by=['state', 'year'], event=True):\n",
        "    if event: \n",
        "        d = pd.get_dummies(df_het['rel_year']).drop(-1, axis=1) \n",
        "        d.columns = ['rel_year_' +str(c).replace('-', 'minus_') for c in d.columns]\n",
        "    else:\n",
        "        d = df_het[['treat']]\n",
        "    d[by[0]] = df_het[by[0]]\n",
        "    d[by[1]] = df_het[by[1]]\n",
        "    for col in d.columns: \n",
        "        if col in by:\n",
        "            pass\n",
        "        else: \n",
        "            for c in by:\n",
        "                d = demean(d, col, c)\n",
        "    d = d.drop(by, axis=1)\n",
        "    d['dep_var'] = df_het['dep_var']\n",
        "    return d\n",
        "## Demean the relative years features for event studies\n",
        "d_event = apply_demeaning(df_het, by=['state', 'year'], event=True)\n",
        "\n",
        "## Demean the treatment indicator for ATT estimation\n",
        "d = apply_demeaning(df_het, by=['unit', 'year'], event=False)\n",
        "\n",
        "d_event.head()"
      ],
      "id": "c4de15d5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We now have a data set with 42 columns focused on the treatment structures, but implicitly controls for the variation due to state and time. We'll see below that this representation of the data will correctly estimate the treatment effects. \n",
        "\n",
        "### Event Study and De-Meaning\n",
        "Now we'll use the de-meaned data structure above to estimate an event study using `Bambi`. \n"
      ],
      "id": "7f510f79"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| \n",
        "x_cols = ' + '.join([c for c in d_event.columns if c != 'dep_var'])\n",
        "model_twfe_event = bmb.Model(f\"dep_var ~ + {x_cols}\", d_event)\n",
        "idata_twfe_event = model_twfe_event.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True},)\n"
      ],
      "id": "4007afa1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model_twfe_event"
      ],
      "id": "bcf8ccfa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can then plot the event-study and observe a similar pattern to the one observed with `pyfixest`. \n"
      ],
      "id": "d5a761ea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_event_study(idata, ax, color='blue', model='demeaned'):\n",
        "    summary_df = az.summary(idata)\n",
        "    cols = [i for i in summary_df.index if 'rel' in i]\n",
        "    summary_df = summary_df[summary_df.index.isin(cols)]\n",
        "    x = range(len(summary_df))\n",
        "    ax.scatter(x, summary_df['mean'], label=model, color=color)\n",
        "    ax.plot([x, x], [summary_df['hdi_3%'],summary_df['hdi_97%']],   color=color)\n",
        "    ax.set_title(\"Event Study\")\n",
        "    return ax\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 5))\n",
        "plot_event_study(idata_twfe_event, ax)\n",
        "ax.legend();"
      ],
      "id": "2e3c8d87",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Similarly, we can de-mean the simple treatment indicator using the group means and marginalise over time periods to find a single treatment effect estimate. \n"
      ],
      "id": "1801a422"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "model_twfe_trt_demean = bmb.Model(f\"dep_var ~ treat\", d)\n",
        "idata_twfe_trt_demean = model_twfe_trt_demean.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True},)\n"
      ],
      "id": "1fe88734",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(idata_twfe_trt_demean)"
      ],
      "id": "da52970a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Which again accords with the reported values from `pyfixest`. This is equivalent to using a Mundlak device as we can see below: \n",
        "\n",
        "### TWFE by Mundlak Device\n",
        "\n",
        "Woolridge recounts that the TWFE is equivalent to a Mundlak regression where: \n",
        "\n",
        "> [The Mundlak devices] $\\bar{X_{i}}$ and $\\bar{X_{t}}$ effectively act as sufficient statistics in accounting for any unit-specific heterogeneity and time-specific heterogeneity that\n",
        "is correlated with $X_{it}$. Rather than having to include (N − 1) + (T − 1) control variables, it suffices to include 2K control variables, $\\bar{X_{i}}$, $\\bar{X_{t}}$ - _Two-Way Fixed Effects, the Two-Way Mundlak Regression, and Difference-in-Differences Estimators_\n",
        "\n",
        "We will see an example of this equivalence here."
      ],
      "id": "feb30685"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "df_het['unit_mean'] = df_het.groupby('unit')['treat'].transform(np.mean)\n",
        "df_het['time_mean'] = df_het.groupby('year')['treat'].transform(np.mean)\n",
        "\n",
        "model_twfe_trt = bmb.Model(f\"dep_var ~ treat\", df_het)\n",
        "idata_twfe_trt = model_twfe_trt.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "model_twfe_trt_mundlak = bmb.Model(f\"dep_var ~ treat + unit_mean + time_mean\", df_het)\n",
        "idata_twfe_trt_mundlak = model_twfe_trt_mundlak.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})"
      ],
      "id": "ff990d91",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.plot_forest([idata_twfe_trt_demean, idata_twfe_trt_mundlak, idata_twfe_trt], combined=True, var_names=['treat'], model_names=['De-meaned', 'Mundlak', 'Simple']);"
      ],
      "id": "395f8d0e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The de-meaned TWFE estimator and the Mundlak specification result in identical estimates and differ from the naive estimate that fails to control group level confounds. The Mundlak specification is far easier to implement and offers altnerative ways to parameterise a model capable of adjusting for the group level confounding.\n",
        "\n",
        "### Functional Form and Richly Parameterised Regressions\n",
        "\n",
        "The vanilla TWFE estimator _can_ successfully recover the treatment effects in DiD designs and facilitate event studies of the same. However, the details of the estimation matter because this functional form is not always robust. Here we'll see other options that can recover substantially the same inferences and may prove more robust as we'll see below. The key to each is to articulate enough structural features that allow the model to modify effects based on the suspected group level confounds. Most crucially, the model needs to express (or account for) variation due to _relevant_ data generating process.  \n"
      ],
      "id": "d837ae11"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "df_het['state_mean'] = df_het.groupby('state')['treat'].transform(np.mean)\n",
        "df_het['time_mean'] = df_het.groupby('year')['treat'].transform(np.mean)\n",
        "df_het['cohort_mean'] = df_het.groupby('group')['treat'].transform(np.mean)\n",
        "\n",
        "model_twfe_event_1 = bmb.Model(f\"dep_var ~ 1 + C(year) + state_mean + C(rel_year, Treatment(reference=-1)) \", df_het)\n",
        "idata_twfe_event_1 = model_twfe_event_1.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "\n",
        "formula = \"\"\" dep_var ~ 1 + time_mean:state_mean + C(rel_year, Treatment(reference=-1))\"\"\"\n",
        "twfe_model_ols = smf.ols(formula, data=df_het).fit()\n",
        "twfe_model_ols.summary()\n",
        "param_est = pd.DataFrame(twfe_model_ols.params, columns=['estimate']).iloc[1:-1]\n",
        "param_est['index_number'] = list(range(len(param_est)))\n",
        "temp = (param_est.reset_index()\n",
        ")\n",
        "param_est = temp[(~temp['index'].str.contains(':')) & (temp['index'].str.contains('rel'))]\n",
        "param_est.reset_index(inplace=True)\n",
        "\n",
        "\n",
        "model_twfe_event_2 = bmb.Model(f\"dep_var ~ (1 | year) + state_mean + C(rel_year, Treatment(reference=-1)) \", df_het)\n",
        "idata_twfe_event_2 = model_twfe_event_2.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})\n"
      ],
      "id": "de6393f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Having estimated the various alternatives model specifications we compare each against our baseline de-meaned event-study.\n"
      ],
      "id": "7a4628fa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| \n",
        "fig, axs = plt.subplots(2, 2, figsize=(20, 10))\n",
        "axs = axs.flatten()\n",
        "plot_event_study(idata_twfe_event, axs[0], model='Manual DeMeaned')\n",
        "plot_event_study(idata_twfe_event, axs[1], model='Manual DeMeaned')\n",
        "plot_event_study(idata_twfe_event, axs[2], model='Manual DeMeaned')\n",
        "plot_event_study(idata_twfe_event, axs[3], model='Manual DeMeaned')\n",
        "plot_event_study(idata_twfe_event_1, axs[0], color='green', model='Fixed Effects Saturated Bayes')\n",
        "plot_event_study(idata_twfe_event_2, axs[1], color='purple', model='Hierarchical Effects Saturated Bayes')\n",
        "axs[2].scatter(param_est['index'], param_est['estimate'], color='red', label='Mundlak Interaction Features OLS')\n",
        "tidy = fit_twfe_event.tidy()\n",
        "xs = range(len(tidy))\n",
        "tidy.reset_index(inplace=True)\n",
        "axs[3].scatter(xs, tidy['Estimate'], color='orange', label='pyfixest TWFE')\n",
        "axs[3].plot([xs, xs], [tidy['2.5%'],tidy['97.5%']], color='orange')\n",
        "axs[2].set_xticks([])\n",
        "axs[0].set_title(\"dep_var ~ 1 + C(year) + state_mean + C(rel_year, Treatment(reference=-1))\")\n",
        "axs[1].set_title(\"dep_var ~ (1 | year) + state_mean + C(rel_year, Treatment(reference=-1))\")\n",
        "axs[2].set_title(\"dep_var ~ 1 + time_mean:state_mean + C(rel_year, Treatment(reference=-1))\")\n",
        "axs[3].set_title(\"dep_var ~ i(rel_year, ref=-1.0) | state + year\")\n",
        "axs[0].legend()\n",
        "axs[1].legend()\n",
        "axs[2].legend()\n",
        "axs[3].legend();"
      ],
      "id": "62d03731",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "`\n",
        "\n",
        "This suggests that there are a variety of functional forms even just using regression specifications that seek to control from different types of group level confounding. In this example data most of the functional forms that seek to control for time and state level effects seem to converge in their answers. We will now switch to an example where the vanilla TWFE breaks down. \n",
        "\n",
        "## Issues with TWFE and Richly Parameterised Linear Models\n",
        "\n",
        "We draw on the example from Pedro Sant'Anna [here](https://psantanna.com/posts/twfe) where it is demonstrated that the vanilla TWFE estimator breaks down under various conditions. These conditions are often related to staggered roll out of a treatment. This staggered roll out induces dynamic changes in the composition of treatment group over time. Appropriate inference needs to carefully control for the interaction effects due to staggered treatment. In particular we need our model of the situation to reflect this aspect of the data generating process.  \n",
        "\n",
        "Let's generate some data. "
      ],
      "id": "39ceeeee"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "true_mu = 1\n",
        "\n",
        "def make_data(nobs = 1000, nstates = 40):\n",
        "    ids = list(range(nobs))\n",
        "    states = np.random.choice(range(nstates), size=nobs, replace=True)\n",
        "    unit = pd.DataFrame({'unit': ids, \n",
        "                        'state': states, \n",
        "                        'unit_fe': np.random.normal(states/5, 1, size=nobs),\n",
        "                        'mu': true_mu})\n",
        "    \n",
        "    year = pd.DataFrame({'year': pd.date_range('1980-01-01', '2010-01-01', freq='y'), \n",
        "    'year_fe': np.random.normal(0, 1, 30) })\n",
        "    year['year'] = year['year'].dt.year\n",
        "\n",
        "    treat_taus = pd.DataFrame({'state': np.random.choice(range(nstates), size=nstates, replace=False),\n",
        "    'cohort_year': np.sort([1986, 1992, 1998, 2004]*10)\n",
        "    })\n",
        "\n",
        "    cross_join = pd.DataFrame([row for row in product(range(nobs), year['year'].unique())], columns =['unit', 'year'])\n",
        "    cross_join = cross_join.merge(unit, how='left', left_on='unit', \n",
        "    right_on='unit')\n",
        "    cross_join = cross_join.merge(year, how='left', left_on='year', \n",
        "    right_on='year')\n",
        "    cross_join = cross_join.merge(treat_taus, how='left', left_on='state', right_on='state')\n",
        "    cross_join = cross_join.assign(\n",
        "        error = np.random.normal(0, 1, len(cross_join)),\n",
        "        treat = lambda x: np.where(x['year'] >= x['cohort_year'], 1, 0)\n",
        "    )\n",
        "    cross_join = cross_join.assign(tau = np.where(cross_join['treat'] == 1, cross_join['mu'], 0), \n",
        "    ).assign(year_fe = lambda x: x['year_fe'] + 0.1*(x['year']-x['cohort_year']))\n",
        "\n",
        "    cross_join['tau_cum'] = cross_join.groupby('unit')['tau'].transform(np.cumsum)\n",
        "    cross_join = cross_join.assign(dep_var = lambda x: 2010-x['cohort_year'] + \n",
        "    x['unit_fe'] + x['year_fe'] + x['tau_cum'] + x['error'])\n",
        "    cross_join['rel_year'] =  cross_join['year'] - cross_join['cohort_year']\n",
        "\n",
        "    \n",
        "    return cross_join\n",
        "\n",
        "sim_df = make_data(500, 40)\n",
        "sim_df.head()"
      ],
      "id": "7b6b4a22",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now plot the staggered nature of the imagined treatment regime. \n"
      ],
      "id": "e3baa05b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "\n",
        "for unit in sim_df['unit'].unique()[0:100]:\n",
        "    temp = sim_df[sim_df['unit'] == unit]\n",
        "    ax.plot(temp['year'], temp['dep_var'], alpha=0.1, color='grey')\n",
        "\n",
        "sim_df.groupby(['cohort_year', 'year'])[['dep_var']].mean().reset_index().pivot(index='year', columns='cohort_year', values='dep_var').plot(ax=ax)\n",
        "ax.axvline(1986)\n",
        "ax.axvline(1992, color='orange')\n",
        "ax.axvline(1998, color='green')\n",
        "ax.axvline(2004, color='red')\n",
        "ax.set_title(\"Simulated Cohorts Homogenous Treatment Effects \\n All Eventually Treated\", fontsize=20)\n",
        "ax.legend()"
      ],
      "id": "5e1d2024",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This data will present problems for the vanilla TWFE estimator. The issues stems from how each cohort receives a treatment and there are periods in the data when no group is in the \"control\" group. We can see how this plays out with de-meaning TWFE strategy. \n"
      ],
      "id": "e3bbaa0f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fit_twfe = pf.feols(\n",
        "    \"dep_var ~ i(rel_year, ref=-1.0) | state + year\",\n",
        "    sim_df,\n",
        "    vcov={\"CRV1\": \"state\"},\n",
        ")\n",
        "\n",
        "\n",
        "figsize = [1200, 400]\n",
        "fit_twfe.iplot(\n",
        "    coord_flip=False,\n",
        "    title=\"TWFE-Estimator\",\n",
        "    figsize=figsize,\n",
        "    xintercept=18.5,\n",
        "    yintercept=0,\n",
        ").show()"
      ],
      "id": "a70bbd06",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is not remotely close to the expected pattern. For contrast, consider an alternative estimator.\n"
      ],
      "id": "591b6399"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fit_lpdid = lpdid(\n",
        "    data=sim_df,\n",
        "    yname=\"dep_var\",\n",
        "    gname=\"cohort_year\",\n",
        "    tname=\"year\",\n",
        "    idname=\"unit\",\n",
        "    vcov={\"CRV1\": \"state\"},\n",
        "    pre_window=-17,\n",
        "    post_window=17,\n",
        "    att=False,\n",
        ")\n",
        "\n",
        "fit_lpdid.iplot(\n",
        "    coord_flip=False,\n",
        "    title=\"Local-Projections-Estimator\",\n",
        "    figsize=figsize,\n",
        "    yintercept=0,\n",
        "    xintercept=18.5,\n",
        ").show()"
      ],
      "id": "8858db87",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The initial TWFE estimate is utterly skewed and entirely incorrect. Something dreadful has gone wrong under the hood. For contrast, we've included the Local Projections estimator from the `pyfixest` to show that we _can_ recover the actual treatment effect under this event study with alternative strategies.\n",
        "However, there is more machinary involved in the local-projections estimator.\n",
        "\n",
        "::: {.callout-warning}\n",
        "\n",
        "Note there has been a large volume of literature diagnosing precisely how and where TWFE estimator breakdown. Goodman-Bacon's \"_Difference-in-differences with variation in treatment timing_\" in particular provides a decomposition of the causal estimand that can be recovered under varying treatment regimes. We won't cover this rich area of research here. But we note that it's a lively area of research.\n",
        ":::\n",
        "\n",
        "Instead we want show how to use mundlak devices to recover more reasonable estimates. No fancy estimators, just more regressions. \n",
        "\n",
        "<img src=\"moreregression.png\" width=\"500\" height=\"300\" />\n",
        "\n",
        "Woolridge argues for this approach when he states that\n",
        "\n",
        "> [T]hat there is nothing inherently wrong with TWFE, which is an estimation method. The problem with how TWFE is implemented in DiD settings is that it is applied to a restrictive model...\n",
        "- _Two-Way Fixed Effects, the Two-Way Mundlak Regression, and Difference-in-Differences Estimators_\n",
        "\n",
        "We want to explore different ways of isolating the treatment effects under a variety of model specifications that controls for\n",
        "time-constant treatment intensities, covariates, and interactions between them. That is we want to better express the data generating process in our model of the situation. \n",
        "\n",
        "### Fitting a Variety of Models\n",
        "\n",
        "Consider the following model specifications. \n"
      ],
      "id": "a3b5bd50"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "sim_df['unit_mean'] = sim_df.groupby('unit')['treat'].transform(np.mean)\n",
        "\n",
        "sim_df['state_mean'] = sim_df.groupby('state')['treat'].transform(np.mean)\n",
        "\n",
        "sim_df['cohort_mean'] = sim_df.groupby('cohort_year')['treat'].transform(np.mean)\n",
        "\n",
        "sim_df['time_mean'] = sim_df.groupby('year')['treat'].transform(np.mean)\n",
        "\n",
        "\n",
        "model_twfe = bmb.Model(f\"\"\"dep_var ~ 1  + time_mean:state_mean + C(rel_year, Treatment(reference=-1))\"\"\", sim_df)\n",
        "\n",
        "idata_twfe = model_twfe.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "\n",
        "model_twfe1 = bmb.Model(f\"\"\"dep_var ~ 1  + time_mean* state_mean + C(cohort_year) + C(rel_year, Treatment(reference=-1))\"\"\", sim_df)\n",
        "\n",
        "idata_twfe1 = model_twfe1.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "\n",
        "model_twfe2 = bmb.Model(f\"\"\"dep_var ~ 1  + cohort_mean: state_mean + C(rel_year, Treatment(reference=-1))\"\"\", sim_df)\n",
        "\n",
        "idata_twfe2 = model_twfe2.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "model_twfe3 = bmb.Model(f\"\"\"dep_var ~ (1| year)  + state_mean + C(rel_year, Treatment(reference=-1))\"\"\", sim_df)\n",
        "idata_twfe3 = model_twfe3.fit( inference_method=\"nuts_numpyro\",\n",
        "    idata_kwargs={\"log_likelihood\": True})"
      ],
      "id": "1d956006",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "These latter models will recover the appropriate treatment effects with slight variations due to the adapted functional form. The initial models will fail to capture the pattern correctly. \n"
      ],
      "id": "8c014728"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| \n",
        "fig, axs = plt.subplots(4, 1, figsize=(10, 15), sharey=True)\n",
        "axs = axs.flatten()\n",
        "plot_event_study(idata_twfe, ax=axs[0], model='Additive Mundlak')\n",
        "plot_event_study(idata_twfe1, ax=axs[1], color='red', model='Mundlak State & Time Interactions')\n",
        "plot_event_study(idata_twfe2, ax=axs[2], color='green', model='Mundlak Cohort & State Interactions')\n",
        "plot_event_study(idata_twfe3, ax=axs[3], color='purple', model='Hierarchical Time + Mundlak State')\n",
        "axs[0].set_title(str(model_twfe.formula))\n",
        "axs[1].set_title(str(model_twfe1.formula))\n",
        "axs[2].set_title(str(model_twfe2.formula))\n",
        "axs[3].set_title(str(model_twfe3.formula))\n",
        "xs = np.linspace(0, 45, 45)\n",
        "xs_centered = xs - 22\n",
        "true_effect = np.where(xs_centered <= 0, 0, (xs_centered +1))\n",
        "axs[0].plot(xs, true_effect, color='k', alpha=0.6, label='True effect')\n",
        "axs[1].plot(xs, true_effect, color='k', alpha=0.6, label='True effect')\n",
        "axs[2].plot(xs, true_effect, color='k', alpha=0.6, \n",
        "label='True effect')\n",
        "axs[3].plot(xs, true_effect, color='k', alpha=0.6,\n",
        "label='True effect')\n",
        "axs[0].legend()\n",
        "axs[1].legend()\n",
        "axs[2].legend()\n",
        "axs[3].legend();"
      ],
      "id": "9a9c0235",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note how the naive mundlak approach also exhibits odd behaviour as we saw in the TWFE estimation routine above. Adding additional interactions and controlling for the staggered launch dates seems to help isolate the real pattern in the data. We've seen approximate success in a number of these richly parameterised versions of simple event study regressions. But the idiosyncracies of any one sample will contort and distort the estimates away from the true values. We might hope for more stability in expectation over repeated draws from this kind of data-generating process. Consider the following Bootstrapping estimation routine. \n",
        "\n",
        "### Evaluating Robustness of Functional Form\n"
      ],
      "id": "c62030aa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "fig, axs = plt.subplots(2, 1, figsize=(10, 15))\n",
        "axs = axs.flatten()\n",
        "event_coefs = []\n",
        "event_coefs1 = []\n",
        "\n",
        "def fit_ols(formula, df_het):\n",
        "    twfe_model_ols = smf.ols(formula, data=df_het).fit()\n",
        "    twfe_model_ols.summary()\n",
        "    param_est = pd.DataFrame(twfe_model_ols.params, columns=['estimate']).iloc[1:-1]\n",
        "    param_est['index_number'] = list(range(len(param_est)))\n",
        "    temp = (param_est.reset_index())\n",
        "    param_est = temp[(~temp['index'].str.contains(':')) & (temp['index'].str.contains('rel'))]\n",
        "    param_est.reset_index(inplace=True)\n",
        "    try:\n",
        "        param_est['rel_year'] =(param_est['index'].str.split('[', expand=True)[1].str.replace('T.', '')\n",
        "        .str.replace(']', ''))\n",
        "    except Exception as e:\n",
        "        param_est['rel_year'] = param_est['level_0'] - 22\n",
        "    param_est['rel_year'] = param_est['rel_year'].astype(int)\n",
        "    param_est.set_index('rel_year', inplace=True)\n",
        "    return param_est\n",
        "\n",
        "for i in range(100):\n",
        "    df_het = make_data(500, 40)\n",
        "    df_het['state_mean'] = df_het.groupby('state')['treat'].transform(np.mean)\n",
        "    df_het['time_mean'] = df_het.groupby('year')['treat'].transform(np.mean)\n",
        "    df_het['cohort_mean'] = df_het.groupby('cohort_year')['treat'].transform(np.mean)\n",
        "    df_het['unit_mean'] = df_het.groupby('unit')['treat'].transform(np.mean)\n",
        "\n",
        "    formula = \"\"\" dep_var ~ 1 + time_mean + state_mean + cohort_mean  + C(rel_year, Treatment(reference=-1)) \"\"\"\n",
        "    formula1 = \"\"\" dep_var ~ 1 + C(cohort_year) + time_mean:unit_mean + C(rel_year, Treatment(reference=-1))\"\"\"\n",
        "\n",
        "    param_est = fit_ols(formula, df_het)\n",
        "    axs[0].plot(param_est['estimate'], color='blue', alpha=0.3)\n",
        "    event_coefs.append(param_est['estimate'])\n",
        "    param_est1 = fit_ols(formula1, df_het)\n",
        "    axs[1].plot(param_est1['estimate'], color='blue', alpha=0.3)\n",
        "    event_coefs1.append(param_est1['estimate'])\n",
        "\n",
        "bootstrap_df = pd.DataFrame(event_coefs)\n",
        "mean_df = bootstrap_df.mean(axis=0)\n",
        "mean_df.index = param_est.index\n",
        "mean_df.plot(ax=axs[0], color='red')\n",
        "axs[0].set_title(f\"\"\"Bootstrapped Estimates of Demean Event Study DGP \\n {formula}\"\"\")\n",
        "\n",
        "bootstrap_df1 = pd.DataFrame(event_coefs1)\n",
        "mean_df = bootstrap_df1.mean(axis=0)\n",
        "mean_df.index = param_est1.index\n",
        "mean_df.plot(ax=axs[1], color='red')\n",
        "axs[1].set_title(f\"\"\"Bootstrapped Estimates of Event Study DGP \\n\n",
        "{formula1}\"\"\");"
      ],
      "id": "2b64d8e5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we see the importance of robustness tests in estimation techniques. In the above plot we see something like the correct pattern emerging in expectation, but absurd estimates occuring on individual cases. Whereas the bottom plot appears much more consistent across multiple draws from the data generating process. This points to something about the justification required for a credible result. Asymptotic accuracy is generally not sufficient for inducing credibility in any particular analysis of finite data.\n",
        "\n",
        "We can also compare these models on standard adequacy measures. \n"
      ],
      "id": "acc5e829"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.compare({'fe_mundlak_naive': idata_twfe, \n",
        "            'mundlak_state_time_interactions_cohort': idata_twfe1, \n",
        "            'mundlak_cohort_state_interactions': idata_twfe2, \n",
        "            'mundlak_state_hierarchical_year': idata_twfe3})"
      ],
      "id": "d5cd8a5f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Again, we can plot the predictive performance of these models. Here we compare two via posterior predictive checks. Notable we see how the model with the better predictive performance also correctly estimates the treatement effects in the above plots. "
      ],
      "id": "17fca6b4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model_twfe3.predict(idata_twfe3, kind='pps')\n",
        "model_twfe.predict(idata_twfe, kind='pps')\n",
        "fig, axs = plt.subplots(2, 1, figsize=(10, 12))\n",
        "axs = axs.flatten()\n",
        "az.plot_ppc(idata_twfe3, ax=axs[0])\n",
        "axs[0].set_title(\"PPC checks for Mundlak State Hierarchical Year\")\n",
        "axs[1].set_title(\"PPC checks for FE Mundlak Naive\")\n",
        "az.plot_ppc(idata_twfe, ax=axs[1]);"
      ],
      "id": "dc16aa23",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "It's certainly possible that parameter recovery accuracy and predictive performance come apart. But in lieu of knowledge of the true data generating processes, the route to credible models is via their calibration against real data. \n",
        "\n",
        "## Conclusion\n",
        "\n",
        "> \"A schema may be transported almost anywhere. The choice of territory for invasion is arbitrary; but the operation within that territory is almost never completely so.\" - Nelson Goodman in _Languages of Art_\n",
        "\n",
        "We've now seen various cases of group-level confounding and strategies to address these issues. We've seen how they give rise to non-trivial questions about the effects of policy, and what can be learned in the face of group-level confounds. The case of TWFE's estimation is especially instructive - here we have an estimation technique applied well in limited circumstances, which ran into trouble when applied in contexts with a diverging data generating process. We all lose our way some of the time, but this misstep led us off the map - we'd followed the trail well past the intended territory. \n",
        "\n",
        "Statistical models do not mirror the world, they project patterns in the data. Each rupture between model and world is a gift that highlights deficits in our understanding - an impropriety of projections. It is therefore a delightful reversal to see, in Woolridge's proof, that the issue is not with the tooling but the thoughtless application of the tool. The unreasonable effectiveness of regression modelling is surely driven by projections of linearity on the world, but it remains compelling in approximation when used well. There are architectural constraints in causal inference - hard unyielding facts, that shape the contours of our design, and structure the steps we can make. The degree to which we can flexibly encode those structures in our models, the more compelling our models will be. It is this recognition of dual fit requirements between world and model - the focus on the conditions for identifiability - that lends causal inference any kind of credibility. The expressive capacity of generalised linear modelling enables us to articulate too many candidate pictures of the world. It's the business of science to cull those pictures, to find only the plausible representations of reality. "
      ],
      "id": "5c541d2b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "pymc_causal",
      "language": "python",
      "display_name": "pymc_causal",
      "path": "/Users/nathanielforde/Library/Jupyter/kernels/pymc_causal"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}