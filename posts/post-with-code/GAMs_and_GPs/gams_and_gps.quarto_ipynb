{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"GAMs and GPs: Flexibility and Calibration\"\n",
        "date: \"2024-04-07\"\n",
        "categories: [\"probability\", \"generalised additive models\", \"gaussian processes\"]\n",
        "keep-ipynb: true\n",
        "self-contained: true\n",
        "draft: false\n",
        "execute: \n",
        "  enabled: True\n",
        "jupyter: pymc_causal\n",
        "image: \"Spline.png\"\n",
        "author:\n",
        "    - url: https://nathanielf.github.io/\n",
        "    - affiliation: PyMC dev\n",
        "citation: true\n",
        "---"
      ],
      "id": "dac69df1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import bambi as bmb\n",
        "import seaborn as sns\n",
        "from pygam.datasets import mcycle\n",
        "from pygam import LinearGAM, s, f, GAM, l, utils\n",
        "import numpy as np\n",
        "import arviz as az\n",
        "import pymc as pm\n",
        "import scipy as sp\n",
        "from patsy import bs as bs_patsy, dmatrix\n",
        "import pytensor.tensor as pt\n",
        "\n",
        "\n",
        "random_seed = 100\n",
        "\n",
        "import warnings\n",
        "\n",
        "warnings.simplefilter('ignore')"
      ],
      "id": "7135887d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# GAMs and GPs: Flexibility and Calibration\n",
        "\n",
        "Flexible Spline models risk overfit and need to be carefully calibrated against real data. Hierarchical models impose structure and aid calibration. We combine them.\n",
        "\n",
        "::: {.callout-note}\n",
        "## Summary \n",
        "_Statistical models both encode structure in their definition and learn structure as they are calibrated against real data. There is a tension between how much structure we encode and how much we allow the model to discover. Too much discovery turns the model into a black-box and we lose interpretability, too much encoded structure and we bias the discovery process and risk losing sight of the data generating mechanism._ \n",
        "\n",
        "_Generalised Additive spline models and Gaussian process models are a tractable set of mathematical abstractions fit for arbitrary function approximation. We demonstrate their flexibility and then continue to explore the interplay between such free wheeling function-approximation and theoretically imposed constraints in the case of hierarchical spline modelling of insurance losses._\n",
        ":::\n",
        "\n",
        "## Theoretical Posits and Scientific Commitments\n",
        "\n",
        "__The scientific enterprise must abstract away details of reality to provide insight into the structure of reality.__ Statistical models of real mechanisms are cobbled together from a variety of abstractions; probability distributions and functional relations cojoined, are then calibrated against observed data. We are building on disparate foundations. Good abstractions aim at modelling the structures or _real patterns_ that matter. It doesn't matter if those abstractions are themselves reflective of reality.\n",
        "\n",
        "> [T]here is no way to establish [a] fully secured, ... starting point of the sciences. There is no tabula rasa. We are like sailors who have to rebuild their ship on the open sea, without ever being able to dismantle it in dry-dock and reconstruct it from its best components. - Otto Neurath\n",
        "\n",
        "This is an apt metaphor for spline models in particular - like these ships built at sea, spline models are constructed from ad-hoc materials fished from the vast ocean of possible models. They are linear approxiations invoked to ride the next wave form.\n",
        "\n",
        "In this blog post we're going to dive into modelling of non-linear functions and explore some of the tooling available in the python eco-system. We'll start by looking into Generalised Additive Models with splines in `pyGAM` before proceeding to look at how Bayesian versions of spline modelling compares to Gaussian processes in `Bambi` and `PyMC`. Finally we will show how hierarchical bayesian models avoid some of the issues of overfit in simpler spline models. \n",
        "\n",
        "Our interest in these models stems from their flexibility to approximate functions of arbitrary complexity. We'll see how the methods work in the case of relatively straightforward toy example and then we'll apply each of the methods to deriving insights into the functional form of insurance loss curves. In this application we adapt a data set discussed in Mick Cooney's `Stan` [case study](https://mc-stan.org/users/documentation/case-studies/losscurves_casestudy.html) to demonstrate the power of hierarchical spline models. Throughout we'll draw on the discussion of these methods in Osvaldo Martin's _\"Bayesian Analysis with Python\"_ for practical details implementing these models. \n",
        "\n",
        "## Generalised Additive models\n",
        "\n",
        "__Nonlinear functions can be approximated with linearly  additive combinations of component features.__ Before delving into the practicalities we'll quickly note some of the theoretical background. The canonical reference for these additive models is Simon Wood's _\"Generalised Additive Models: An Introduction with R\"_ which outlines in some detail the theoretical background of splines and univariate smoothers. The book stresses the trade-offs between the flexibility of splines and the need for cross-validation and penalised estimation methods for spline based modelling. Spline models ape the complexities of esoteric functions by regression-like formulas combining subordinate functions of observed variables to to predict another:\n",
        "\n",
        "$$y \\sim f(x_1) + f(x_2) ...$$\n",
        "\n",
        "The structure of the individual $f$ functions is approximated. So we are approximating $y$ by adding a series of input approximations $\\sum f_{i}$. In R these penalised models fits can be achieved in `mgcv` which incorporates a Wilkinson like formula syntax for model specification: `y ~ s(x) + s(x1)`. The closest implementation in python is available in `PyGam` and we will adopt this package to illustrate the spline based smoothing. \n",
        "\n",
        "### PyGAM and Penalised Fits\n",
        "Let's first look at an example data set on which to demonstrate univariate smoothing patterns using penalised splines. We'll initially look simply at the function calls before going \"under the hood\".\n",
        "\n",
        "Spline models can be optimised by fitting differing _strength_ penalities over a _varying_ number of splines. Splines are used to construct non-linear functions of the input variable which are combined additively in our model equation. The penalities used in the optimisation routines constrain how \"wiggly\" these constructions will be. The number of splines determine how precise our will be. "
      ],
      "id": "c5b1a9a2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "X, y = mcycle(return_X_y=True)\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "ax.scatter(X, y)\n",
        "ax.set_ylabel(\"Acceleration\")\n",
        "ax.set_xlabel(\"Time Step\")\n",
        "ax.set_title(\"Crash Test Dummy Acceleration \\n Simulated Motorcycle Crash\", fontsize=20);"
      ],
      "id": "3b0645a8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we fit a number of different models to account for the herky-jerky nature of the data generating processs. We vary the parameterisations to see how the numbers of splines and strength of the penalty help account for the variation in $y$ over the support of $X$. \n"
      ],
      "id": "46499a66"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gam1 = LinearGAM(s(0, n_splines=5)).fit(X, y)\n",
        "gam2 = LinearGAM(s(0, n_splines=7)).fit(X, y)\n",
        "gam3 = LinearGAM(s(0, n_splines=10)).fit(X, y)\n",
        "gam4 = LinearGAM(s(0, n_splines=15)).fit(X, y)\n",
        "gam5 = LinearGAM(s(0, lam=.1)).fit(X, y)\n",
        "gam6 = LinearGAM(s(0, lam=.5)).fit(X, y)\n",
        "gam7 = LinearGAM(s(0, lam=5)).fit(X, y)\n",
        "gam8 = LinearGAM(s(0, lam=15)).fit(X, y)\n",
        "\n",
        "\n",
        "def plot_fit(gam, X, y, ax, t, c1='b', c2='r'):\n",
        "    XX = gam.generate_X_grid(term=0, n=500)\n",
        "\n",
        "    ax.plot(XX, gam.predict(XX), color=c2, linestyle='--')\n",
        "    ax.plot(XX, gam.prediction_intervals(XX, width=.95), color=c1, ls='--')\n",
        "\n",
        "    ax.scatter(X, y, facecolor='gray', edgecolors='none')\n",
        "    ax.set_title(f\"\"\"95% prediction interval with {t} \\n LL: {gam.statistics_['loglikelihood']}\"\"\");\n",
        "\n",
        "fig, axs = plt.subplots(4,2, figsize=(10, 20))\n",
        "axs = axs.flatten()\n",
        "titles = ['5_splines', '7_splines', '10_splines', '15_splines',\n",
        "'lam=.1', 'lam=.5', 'lam=5', 'lam=15']\n",
        "gs = [gam1, gam2, gam3, gam4, gam5, gam6, gam7, gam8]\n",
        "for ax, g, t in zip(axs, gs, titles):\n",
        "    plot_fit(g, X, y, ax, t)\n"
      ],
      "id": "b841fca1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we've seen the `PyGAM` package applied to fitting our model to the data. In the formula specification we see `y ~ s(i)` where `i` denotes the index of the column variable in the X data. \n",
        "\n",
        "Over the range of of the x-axis we can see how the conditional expectation is more or less well fit to the data depending on how the penalities and complexity of the model is specified. The art and science of developing a GAM model is finding the constraints on the approximation that help capture the observed patterns but do not excessively overfit to the observed data. \n",
        "\n",
        "## Optimising The Parameter Setting\n",
        "\n",
        "__The manner of the the linear combination achieved by GAMs is constrained by the optimisation goal in their model fit.__ We can see from the model summary what is going on under the hood. For a given model specification the summary will report a number of model-fit statistics such as the log-likelihood and the AIC. \n"
      ],
      "id": "21bf0c65"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## Naive Model manually specified splines\n",
        "gam_raw = LinearGAM(s(0, n_splines=10), fit_intercept=False).fit(X, y)\n",
        "print(\"log_likelihood:\", gam_raw.statistics_['loglikelihood'])\n",
        "print(\"AIC:\", gam_raw.statistics_['AIC'])\n"
      ],
      "id": "7db54414",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The question then becomes what changes are induced in the model as we seek to optimise these model fit statistics. \n"
      ],
      "id": "1399eb77"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## model optimised\n",
        "gam = LinearGAM(s(0),  fit_intercept=False)\n",
        "gam.gridsearch(X, y)\n",
        "gam.summary()"
      ],
      "id": "dd253363",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Fortunately, this routine can be performed directly and results in the following differences between the naive and optimised model. \n",
        "\n",
        "### Plot the GAM fits\n"
      ],
      "id": "9ca879bc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "plot_fit(gam_raw, X, y, ax, \"Unoptimised Fit\", c1='orange', c2='green')\n",
        "plot_fit(gam, X, y, ax, \"Optimised Fit\")"
      ],
      "id": "dd8063df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is all well and good! We've seen an approach to modelling that can capture eccentric patterns in raw data. But how does it work and why should we care? If you're familiar with the nomenclature of machine learning, you should think of spline modelling as a variety of feature creation. It generates \"synthetic\" features over the range of the observed variable. These synthetic features are the splines in question. Model building here too then relies on feature selection and principles for model-comparison. \n",
        "\n",
        "### Digression on the usage of \"Splines\" \n",
        "\n",
        "The history of the term \"spline\" is related to the history of draftmanship. Historically splines were thin strips of flexible wood or plastic that could be bent or shaped around a weight or \"knot\" points to express a traceable curve over the space of a \"numberline\". The elastic nature of the spline material allowed it to be bent around the knot points of curvature expressing a smooth or continuous bend. \n",
        "\n",
        "The mathematical technique apes these properties by defining a curve over in an analogous way. We specify \"knots\"  to carve up the support of the random variable $X$ into portions that require different weighting schemes to represent the outcome $y$ in each partition of the support variable. \n",
        "\n",
        "<img src=\"Spline.png\" alt=\"spline\" height=\"500\"/>\n",
        "\n",
        "### Extracting the Splines\n",
        "\n",
        "Returning to our model we can extract the spline features used in the `PyGAM` by invoking the following commands. We first identify the knot points and create the b-spline basis appropriate for the variable $X$. \n"
      ],
      "id": "6656a321"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "knot_edges=utils.gen_edge_knots(X,dtype='numerical')\n",
        "knots=np.linspace(knot_edges[0],knot_edges[-1],len(gam.coef_))\n",
        "\n",
        "splines = utils.b_spline_basis(X, edge_knots=knot_edges, sparse=False)\n",
        "\n",
        "splines_df = pd.DataFrame(splines, columns=[f'basis_{i}' for i in range(len(gam.coef_))])\n",
        "\n",
        "splines_df.head(10)"
      ],
      "id": "b802f46a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "These spline features range the extent of the of covariate space $X$ defining \"partitions\" of the space. The model \"learns\" to capture the shape of the outcome variable $y$ by figuring out how to weight the different portion of this spline basis matrix i.e. the linear combination of this basis matrix with the derived coefficients is a model of our outcome variable. \n",
        "\n",
        "Note how each row is 0 everywhere except within the columns that represent a partition of $X$. Additionally each row sums to unity. These properties are important because they ensure that any weighted combination of this basis represents the outcome variable in a controlled and quite granular manner. The more splines we use the more control we have of the representation, but we also risk overfit. \n",
        "\n",
        "### Plotting the Weighted Spline"
      ],
      "id": "f00576d0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ax = splines_df.dot(gam.coef_).plot(title='Weighted Splines', label='Weighted Combination of Spline Basis', figsize=(10, 6))\n",
        "ax.set_ylabel(\"Acceleration\")\n",
        "ax.set_xlabel(\"Time Steps\")\n",
        "ax.legend();"
      ],
      "id": "d06b31fe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In this manner we can see how the specification of a spline basis can help us model eccentric curves and waves in an outcome space. Spline features are like ad-hoc joists structuring our ship's rigging. Features filling the gaps in our theory, they act like duct-tape binding the pieces together. If we hold this part down there, and jiggle another part here, our theory stays afloat. Spline features exemplify the contorted nature of empirically informed theory construction.\n",
        "\n",
        "Next we'll see how to more directly work with the specification of basis splines, passing these feature matrices into Bambi models. \n",
        "\n",
        "## Bayesian Splines with `bambi`\n",
        "\n",
        "__Spline models can be built and assessed using Bayesian approaches to quantify the uncertainty in the constructed function__. Under the hood `Bambi` makes use of the ['formulae'](github.com/bambinos/formulae) package to allow for formula-like syntax to specify spline basis terms and mixed effect model terms. We leverage this to streamline the specification of spline models and demonstrate different kinds of spline-features. \n"
      ],
      "id": "5233de4b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "knots_6 = np.linspace(0, np.max(X), 6+2)[1:-1]\n",
        "knots_10 = np.linspace(0, np.max(X), 10+2)[1:-1]\n",
        "knots_20 = np.linspace(0, np.max(X), 20+2)[1:-1]\n",
        "\n",
        "df = pd.DataFrame({'X': X.flatten(), 'y': y})\n",
        "formula1 = 'bs(X, degree=0, knots=knots_6)'\n",
        "formula2 = 'bs(X, degree=1, knots=knots_6, intercept=False)'\n",
        "formula3 = 'bs(X, degree=3, knots=knots_6, intercept=False)'\n",
        "formula4 = 'bs(X, degree=3, knots=knots_10, intercept=False)'\n",
        "formula5 = 'bs(X, degree=3, knots=knots_20, intercept=False)'\n",
        "model_spline1 = bmb.Model(f\"y ~ {formula1}\", df)\n",
        "model_spline2 = bmb.Model(f\"y ~ {formula2}\", df)\n",
        "model_spline3 = bmb.Model(f\"y ~ {formula3}\", df)\n",
        "model_spline4 = bmb.Model(f\"y ~ {formula4}\", df)\n",
        "model_spline5 = bmb.Model(f\"y ~ {formula5}\", df)\n",
        "model_spline5"
      ],
      "id": "ed53a75a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As you can see here we are specifying a range of different degrees of spline basis. The different degrees corresspond to the smoothness of the overlapping splines. \n",
        "The `degree=0` splines mean we specify a piecewise constant basis i.e. 0 or 1 within each region of the partition. But we can add more degrees to see more flexible representations of the space. \n"
      ],
      "id": "cc0c8d6c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model_spline5.build()\n",
        "model_spline5.graph()"
      ],
      "id": "58973ee7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The differences here will become clearer as we plot the various spline basis matrices below, but the main thought is that there are different degrees of \"smoothness\" to the linear basis of the spline features.  \n",
        "\n",
        "### Plot the Spline Basis\n",
        "\n",
        "The below functions extract the basis specification from each model and plots the basis design for an increasingly complex series of spline basis matrices. \n"
      ],
      "id": "58da5fe7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_spline_basis(basis, X, ax, title=\"Spline Basis\"):\n",
        "    df = (\n",
        "        pd.DataFrame(basis)\n",
        "        .assign(X=X)\n",
        "        .melt(\"X\", var_name=\"basis_idx\", value_name=\"y\")\n",
        "    )\n",
        "\n",
        "\n",
        "    for idx in df.basis_idx.unique():\n",
        "        d = df[df.basis_idx == idx]\n",
        "        ax.plot(d[\"X\"], d[\"y\"])\n",
        "    \n",
        "    ax.set_title(title)\n",
        "    return ax\n",
        "\n",
        "def plot_knots(knots, ax):\n",
        "    for knot in knots:\n",
        "        ax.axvline(knot, color=\"0.1\", alpha=0.4)\n",
        "    return ax\n",
        "\n",
        "\n",
        "\n",
        "fig, axs = plt.subplots(5, 1, figsize=(9, 20))\n",
        "axs = axs.flatten()\n",
        "axs.flatten()\n",
        "B1 = model_spline1.response_component.design.common[formula1]\n",
        "plot_spline_basis(B1, df[\"X\"].values, ax=axs[0], title=\"Piecewise Constant Basis\")\n",
        "plot_knots(knots_6, axs[0]);\n",
        "\n",
        "B2 = model_spline2.response_component.design.common[formula2]\n",
        "ax = plot_spline_basis(B2, df[\"X\"].values, axs[1], \n",
        "title=\"Piecewise Linear Basis\")\n",
        "plot_knots(knots_6, axs[1]);\n",
        "\n",
        "B3 = model_spline3.response_component.design.common[formula3]\n",
        "ax = plot_spline_basis(B3, df[\"X\"].values, axs[2], \n",
        "title=\"Cubic Spline Basis (6 Knots)\")\n",
        "plot_knots(knots_6, axs[2]);\n",
        "\n",
        "B4 = model_spline4.response_component.design.common[formula4]\n",
        "ax = plot_spline_basis(B4, df[\"X\"].values, axs[3], \n",
        "title=\"Cubic Spline Basis (10 Knots)\")\n",
        "plot_knots(knots_10, axs[3]);\n",
        "\n",
        "\n",
        "B5 = model_spline5.response_component.design.common[formula5]\n",
        "ax = plot_spline_basis(B5, df[\"X\"].values, axs[4], \n",
        "title=\"Cubic Spline Basis (20 Knots)\")\n",
        "plot_knots(knots_20, axs[4]);\n"
      ],
      "id": "cec90a45",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we've seen the nature of the modelling splines we'll fit to the data. By \"fit\" we mean estimate a set of linear coefficients that we can use to additively combine these spline features creating a smooth linear representation of the outcome. \n",
        "\n",
        "### Fit the Individual Spline Models\n",
        "\n",
        "We now combine the spline components within a linear model fit, pulling and tying them together in such a way as to ape the shape of the observed sequence. \n"
      ],
      "id": "0ef473de"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "idata_spline1 = model_spline1.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "idata_spline2 = model_spline2.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "idata_spline3 = model_spline3.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "idata_spline4 = model_spline4.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True})\n",
        "\n",
        "idata_spline5 = model_spline5.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True})"
      ],
      "id": "475f3632",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally we can plot fits achieved by each of the models and compare how the different spline smooths contribute to approxiating the outcome variable.\n",
        "\n",
        "### Plot the Weighted Mean\n"
      ],
      "id": "479c99cb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_weighted_splines(B, idata, formula, ax, knots):\n",
        "    posterior_stacked = az.extract(idata)\n",
        "    wp = posterior_stacked[formula].mean(\"sample\").values\n",
        "\n",
        "    plot_spline_basis(B * wp.T, df[\"X\"].values, ax)\n",
        "    ax.plot(df.X.values, np.dot(B, wp.T), color=\"black\", lw=3, label='Weighted Splines')\n",
        "    plot_knots(knots, ax);\n",
        "    ax.legend()\n",
        "\n",
        "\n",
        "\n",
        "fig, axs = plt.subplots(5, 1, figsize=(10, 20))\n",
        "axs = axs.flatten()\n",
        "axs.flatten()\n",
        "\n",
        "plot_weighted_splines(B1, idata_spline1, formula1, axs[0], knots_6)\n",
        "plot_weighted_splines(B2, idata_spline2, formula2, axs[1], knots_6)\n",
        "plot_weighted_splines(B3, idata_spline3, formula3, axs[2], knots_6)\n",
        "plot_weighted_splines(B4, idata_spline4, formula4, axs[3], knots_10)\n",
        "plot_weighted_splines(B5, idata_spline5, formula5, axs[4], knots_20)"
      ],
      "id": "d043d7d9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we can see how the models with increasingly complex splines are more exactly able to fit the herky jerky trajectory of the outcome variable in each interval. The fewer the intervals, the less flexibility available to the model. \n",
        "\n",
        "### Compare Model Fits\n",
        "\n",
        "As before we can evaluate these model fits and compare them based on leave-one-out cross validation scores and information theoretic complexity measures. \n"
      ],
      "id": "11f98145"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, axs = plt.subplots(1, 2, figsize=(10, 7))\n",
        "axs = axs.flatten()\n",
        "models_dict = {\"piecewise_constant\": idata_spline1, \"piecewise_linear\": idata_spline2, \"cubic_bspline\": idata_spline3, \"cubic_bspline_10\": idata_spline4, \n",
        "\"cubic_bspline_20\": idata_spline5}\n",
        "df_compare = az.compare(models_dict)\n",
        "az.plot_compare(df_compare, ax=axs[0])\n",
        "axs[0].get_legend().remove()\n",
        "az.plot_compare(az.compare(models_dict, 'waic'), ax=axs[1])\n",
        "axs[1].set_yticklabels([])\n",
        "df_compare\n"
      ],
      "id": "c3b4ed0a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we see that the extra complexity of using 20 splines leads to slightly worse performance measures than the less complex but seemingly adequate 10 splines. In other words, it's starting to overfit to the data at 20. This is the price of flexibility and a sign of a model unlikely to generalise well on out-of-sample data. \n"
      ],
      "id": "4aed9491"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "new_data = pd.DataFrame({\"X\": np.linspace(df.X.min() - 5, df.X.max() + 5, num=500)})\n",
        "    \n",
        "model_spline4.predict(idata_spline4, data=new_data, \n",
        "kind='pps', inplace=True)\n",
        "\n",
        "idata_spline4"
      ],
      "id": "fff9fe6e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next we plot the posterior predictive distribution of our observed variable and compare against the observed data. Additionally we plot the 89th and 50% HDI. \n"
      ],
      "id": "3e0467a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ax = az.plot_hdi(new_data['X'], idata_spline4['posterior_predictive']['y'], fill_kwargs={'alpha': 0.2, 'color':'firebrick'}, hdi_prob=0.89, figsize=(10, 8))\n",
        "\n",
        "az.plot_hdi(new_data['X'], idata_spline4['posterior_predictive']['y'], fill_kwargs={'alpha': 0.8, 'color':'firebrick'}, hdi_prob=0.5)\n",
        "\n",
        "y_mean = idata_spline4['posterior_predictive']['y'].mean(dim=('chain', 'draw'))\n",
        "\n",
        "ax.plot(new_data['X'], y_mean, label='Expected posterior predictive', color='k')\n",
        "ax.set_xlabel(\"Time Point\")\n",
        "ax.set_ylabel(\"Acceleration\")\n",
        "\n",
        "ax.scatter(df['X'], df['y'], label='Observed Datapoints')\n",
        "\n",
        "ax.legend()\n",
        "\n",
        "ax.set_title(\"Posterior Predictive Distribution \\n Based on 10 Knots\");"
      ],
      "id": "e09e15a2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This represents a good a clean model fit to the observed data using univariate spline smoothers. However, it's clear that the uncertainty spikes massively with data points even slightly out of the training data. Next we'll see another alternative approach to model this outcome variable using approximate gaussian processes. \n",
        "\n",
        "## Approximate Gaussian processes\n",
        "\n",
        "__Gaussian processes models allow us to express our beliefs about the structure of a function and calibrate these beliefs against the observed data.__ The topic of gaussian processes is rich and complex. Too rich to be fairly covered in this blog post, so we'll just say that we're using a method designed for function approximation that makes use of drawing samples from a multivariate normal distribution under a range of different covariance relationships. The properties of these covariance relations determine the shape and fluidity of the function realisations. We will use the HSGP approximation of gaussian processes models.  \n",
        "\n",
        "The gaussian process models can be somewhat interrogated by examining the different combinations of covariance relationships with priors over the parameters governing the covariance of a sequence of points. For example consider the following parameterisations. "
      ],
      "id": "c5152334"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, axs = plt.subplots(2, 2, figsize=(9, 10))\n",
        "axs = axs.flatten()\n",
        "\n",
        "def plot_cov_draws(ax1, ax2, lengthscale=3, sigma=13):\n",
        "    cov = sigma**2 * pm.gp.cov.ExpQuad(1, lengthscale)\n",
        "    X = np.linspace(0, 60, 200)[:, None]\n",
        "    K = cov(X).eval()\n",
        "\n",
        "    sns.heatmap(pd.DataFrame(K), center=0, xticklabels=[], yticklabels=[], ax=ax1, cmap='crest');\n",
        "    ax1.set_title(f\"Covariance Length Scale {lengthscale}\")\n",
        "    ax2.plot(\n",
        "        X,\n",
        "        pm.draw(\n",
        "            pm.MvNormal.dist(mu=np.zeros(len(K)), cov=K, shape=K.shape[0]), draws=10, random_seed=random_seed\n",
        "        ).T, color='blue', alpha=0.5\n",
        "    )\n",
        "    ax2.set_title(f\"Samples from the GP prior \\n lengthscale: {lengthscale}, sigma: {sigma}\")\n",
        "    plt.ylabel(\"y\")\n",
        "    plt.xlabel(\"X\");\n",
        "\n",
        "plot_cov_draws(axs[0], axs[1])\n",
        "plot_cov_draws(axs[2], axs[3], lengthscale=10, sigma=13)"
      ],
      "id": "9d683338",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We've specified the range of X to reflect the support of the acceleration example and allowed the draws to be informed by a covariance function we have parameterised using the Exponentiated Quadratic kernel. We've additionally tweaked the lengthscale to demonstrate how proximity in the sequence informs the kernel and determines the shape of the covariance structure. \n",
        "\n",
        "$$k(x, x') = \\mathrm{exp}\\left[ -\\frac{(x - x')^2}{2 \\ell^2} \\right]$$\n",
        "\n",
        "The plot on the left highlights the importance of the lengthscale parameter over the sequence. The wider the central shading is the more pronounced is the correlation among more points in the sequence. The patterns to the right show a good range of \"wiggliness\" that they should be flexible enough to capture the shape of the acceleration. These are the constraints of structure we can impose of the theoretical realisations of our model. If we can calibrate the model and derive posterior parameters against the observed data, we can learn the probable shape of our functional relationship. \n",
        "\n",
        "### Priors on Gaussian Processes\n",
        "\n",
        "Consider the following specification for the priors\n"
      ],
      "id": "b6fe586e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, axs = plt.subplots(1, 2, figsize=(9, 6))\n",
        "axs = axs.flatten()\n",
        "axs[0].hist(pm.draw(pm.InverseGamma.dist(mu=1, sigma=1), 1000), ec='black', bins=30);\n",
        "axs[0].set_title(\"Priors for Lengthscale \\n in ExpQuad Kernel\")\n",
        "axs[1].hist(pm.draw(pm.Exponential.dist(lam=1), 1000), ec='black', bins=30);\n",
        "axs[1].set_title(\"Priors for Amplitude \\n in ExpQuad Kernel\")"
      ],
      "id": "2fc52408",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We use these to specify priors on the Hilbert space approximation of gaussian priors available in the `Bambi` package. \n"
      ],
      "id": "e59e7afa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "prior_hsgp = {\n",
        "    \"sigma\": bmb.Prior(\"Exponential\", lam=1), # amplitude\n",
        "    \"ell\": bmb.Prior(\"InverseGamma\", mu=1, sigma=1) # lengthscale\n",
        "}\n",
        "\n",
        "# This is the dictionary we pass to Bambi\n",
        "priors = {\n",
        "    \"hsgp(X, m=10, c=1)\": prior_hsgp,\n",
        "    \"sigma\": bmb.Prior(\"HalfNormal\", sigma=4)\n",
        "}\n",
        "model_hsgp = bmb.Model(\"y ~ 0 + hsgp(X, m=10, c=1)\", df, priors=priors)\n",
        "model_hsgp\n"
      ],
      "id": "9526eb09",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here we've set the `m=10` to determine the number of basis vectors used in the Hilbert space approximation. The idea differs in detail from the spline based approximations we've seen, but it's perhaps useful to think of the process in the same vein. Here again we have a theory of the world expressed as a function of opaque components jerry-rigged for modelling some phenomena. \n"
      ],
      "id": "f431df7c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "idata_hsgp = model_hsgp.fit(inference_method=\"nuts_numpyro\",target_accept=0.95, random_seed=121195, \n",
        "idata_kwargs={\"log_likelihood\": True})\n",
        "print(idata_hsgp.sample_stats[\"diverging\"].sum().to_numpy())"
      ],
      "id": "f68d0a0e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This model fits and the sampling seems to have worked well. \n"
      ],
      "id": "dfaf11a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.plot_trace(idata_hsgp, backend_kwargs={\"layout\": \"constrained\"}, figsize=(9, 15));\n"
      ],
      "id": "46e47507",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The lengthscale and sigma parameters we have learned by calibrating our priors against the data. The degree to which these parameters are meaningful depend a little on how familar you are with covariance matrix kernels and their properties, so we won't dwell on the point here. \n"
      ],
      "id": "f69063f8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(idata_hsgp, var_names=['hsgp(X, m=10, c=1)_ell', 'hsgp(X, m=10, c=1)_sigma', 'y_sigma', 'hsgp(X, m=10, c=1)_weights'])\n"
      ],
      "id": "e17b9213",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "But again we can sample from the posterior predictive distribution of the outcome variable \n"
      ],
      "id": "bace1958"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model_hsgp.predict(idata_hsgp, data=new_data, \n",
        "kind='pps', inplace=True)\n",
        "\n",
        "idata_hsgp"
      ],
      "id": "89f8622b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "and plot the model fit to see if it can recover the observed data. \n"
      ],
      "id": "c276e714"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ax = az.plot_hdi(new_data['X'], idata_hsgp['posterior_predictive']['y'], fill_kwargs={'alpha': 0.2, 'color':'firebrick'}, figsize=(9, 8))\n",
        "\n",
        "az.plot_hdi(new_data['X'], idata_hsgp['posterior_predictive']['y'], fill_kwargs={'alpha': 0.8, 'color':'firebrick'}, hdi_prob=0.5)\n",
        "\n",
        "y_mean = idata_hsgp['posterior_predictive']['y'].mean(dim=('chain', 'draw'))\n",
        "\n",
        "ax.plot(new_data['X'], y_mean, label='Expected posterior predictive', color='k')\n",
        "\n",
        "ax.scatter(df['X'], df['y'], label='Observed Datapoints')\n",
        "\n",
        "ax.legend()\n",
        "\n",
        "ax.set_title(\"Posterior Predictive Distribution \\n Based on HSGP approximation\");\n"
      ],
      "id": "52910e57",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here again we've allowed the model to extrapolate beyond the observed data but we achieve far more reasonable extrapolation than with the Spline model. And we can compare other performance metrics versus the spline models to see that by the aggregate performance measures our HSGP model seems to come out on top too. \n"
      ],
      "id": "893e2771"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "models_dict = {\"piecewise_constant\": idata_spline1, \"piecewise_linear\": idata_spline2, \"cubic_bspline\": idata_spline3, \"cubic_bspline_10\": idata_spline4, \n",
        "\"cubic_bspline_15\": idata_spline5, 'hsgp': idata_hsgp}\n",
        "df_compare = az.compare(models_dict)\n",
        "df_compare\n"
      ],
      "id": "ca274f51",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "For a deeper dive on HSGP you might consult [Juan Orduz's](https://juanitorduz.github.io/) work [here](https://www.pymc.io/projects/examples/en/latest/gaussian_processes/GP-Births.html)\n",
        "\n",
        "## Bayesian Penalised Splines (Smoothing Priors)\n",
        "\n",
        "__Priors can be used in the same way to that regularisation techniques are deployed in machine learning.__ They serve as a kind of extra model parameter used to effect a variable selection routine. In the case of splines we are creating these synthetic features and this can be seen as a generating a feature selection problem. So far we have discussed priors as a means of imposing structure based on our knowledge of the problem but we can also use priors to automate feature selection over spline features. \n",
        "\n",
        "Here we fit a two spline models to the speed-test data set but we use 60 knot points to generate our spline features. This is wildy excessive for the data set in question. We show how to use non-centered parameterisation with a \"smoothing\" trick to induce a good fit despite excessive features. In this way we're removing the burden of manually specifying the spline structure. This is akin to penalisation methods used in `PyGam` but with a Bayesian flavour. \n"
      ],
      "id": "7e0313a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "max_dev= len(y)\n",
        "num_knots=60\n",
        "knot_list = np.linspace(0, np.max(X), num_knots)[2:-2]\n",
        "dev_periods = np.linspace(0, np.max(X), len(y))\n",
        "\n",
        "Bx = dmatrix(\n",
        "    \"bs_patsy(dev_periods, knots=knots, degree=3, include_intercept=False)\",\n",
        "    {\"dev_periods\": dev_periods, \"knots\": knot_list},\n",
        ")\n",
        "Bx\n",
        "\n",
        "def penalised_model(Bx, penalised=True):\n",
        "    with pm.Model() as model:\n",
        "        basis = pm.MutableData('basis', np.asfortranarray(Bx))\n",
        "\n",
        "        if penalised:\n",
        "            sigma_a = pm.HalfCauchy('sigma_a', 5.)\n",
        "            a0 = pm.Normal('a0', 0., 10.)\n",
        "            delta_a = pm.Normal('delta_a', 0., 1.,shape=num_knots)\n",
        "            a = pm.Deterministic('a', a0 + (sigma_a * delta_a).cumsum())\n",
        "        else: \n",
        "            b = pm.Normal('delta_a', 0., 25,\n",
        "            shape=num_knots)\n",
        "            a0 = pm.Normal('a0', 0, 10)\n",
        "            a = pm.Deterministic('a', a0 + b)\n",
        "        \n",
        "        sigma = pm.HalfCauchy('sigma', 5.)\n",
        "        obs = pm.Normal('obs', pm.math.dot(basis, a), sigma, observed=y)\n",
        "        idata = pm.sample(target_accept=.95, idata_kwargs={\"log_likelihood\": True})\n",
        "    \n",
        "    return model, idata\n",
        "\n",
        "model_raw, idata_raw = penalised_model(Bx, penalised=False)\n",
        "model_penalised, idata_penalised = penalised_model(Bx, penalised=True)"
      ],
      "id": "4cc05922",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The model structure is as follows:\n"
      ],
      "id": "c249e0fd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pm.model_to_graphviz(model_penalised)"
      ],
      "id": "c37c6af3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This parameterisation trick is owed to work by Austin Rochford and Adrian Seyboldt discussed [here](https://gist.github.com/AustinRochford/d640a240af12f6869a7b9b592485ca15). We can see how the two parameterisations induce quite distinct values on the coefficients for splines. \n"
      ],
      "id": "547091e8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, ax = plt.subplots(figsize=(9, 20))\n",
        "az.plot_forest([idata_raw, idata_penalised], var_names=['a'], combined=True, ax=ax, model_names=['raw', 'penalised'])\n",
        "ax.fill_betweenx(range(160), -25, 25, alpha=0.2, color='red');\n"
      ],
      "id": "7dd0464f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This results in much different posterior predictive fits. The un-smoothed spline fit overfits to the small partitions of the spline features, whereas the smoothing spline model achieves a reasonable fit recovering the smooth structure of the data generating process. \n"
      ],
      "id": "676d0bd3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "B_df = pd.DataFrame(Bx)\n",
        "weights = az.summary(idata_penalised, var_names='a')['mean']\n",
        "fig, ax = plt.subplots(figsize=(8, 7))\n",
        "processed = np.array([np.dot(B_df, az.extract(idata_penalised['posterior']['a'])['a'].to_numpy()[:, i]) for i in range(4000)])\n",
        "az.plot_hdi(range(len(y)), processed, ax=ax,  fill_kwargs={'alpha': 0.4, 'color':'firebrick'})\n",
        "az.plot_hdi(range(len(y)), processed, ax=ax,  fill_kwargs={'alpha': 0.8, 'color':'firebrick'}, hdi_prob=.50)\n",
        "weights_raw = az.summary(idata_raw, var_names='a')['mean']\n",
        "ax.plot(range(len(y)), np.dot(B_df, weights), color='black', label='Cubic_Bsplines_60_Penalised')\n",
        "ax.plot(range(len(y)), np.dot(B_df, weights_raw), color='blue', linestyle='--', label='Cubic_Bsplines_60_unpenalised')\n",
        "ax.set_title(\"Bayesian Automatic Regularisation \\n Smoothing Priors over 60 Knots\")\n",
        "ax.legend();\n"
      ],
      "id": "eff1344d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is reflected in the model performance measures as well. \n"
      ],
      "id": "c657453f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "models_dict = {\"piecewise_constant\": idata_spline1, \"piecewise_linear\": idata_spline2, \"cubic_bspline\": idata_spline3, \"cubic_bspline_10\": idata_spline4, \n",
        "\"cubic_bspline_20\": idata_spline5, 'hsgp': idata_hsgp, 'spline_penalised_bayes': idata_penalised, 'cubic_bspline_60': idata_raw}\n",
        "df_compare = az.compare(models_dict)\n",
        "df_compare\n"
      ],
      "id": "4b434ea8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This functionality of Bayesian priors is not unique to spline models. We can mirror Lasso regression models with double-exponential prior specifications. Ridge regrssion is provably a species of regression models with Normal priors pulled toward 0. Other alternatives such horse-shoe and slab and spike specifications offer a rich range of bayesian approaches to variable selection methods with sparse data.  \n",
        "\n",
        "### Recap\n",
        "\n",
        "So far we've seen how we can use splines and gauassian processes to model highly eccentric functional relationships where the function could be approximated with univariate smoothing routine. These are two distinct abstractions which seem adequately fit to the world, but demand very different ways of thinking about the underlying reality. This is no fundamental contradiction in so far as the world admits many descriptions. \n",
        "\n",
        "> [K]nowledge develops in a multiplicity of theories, each with it's limited utility ... These theories overlap very considerable in their logical laws and in much else, but that they add up to an integrated and consistent whole is only a worthy ideal and not a pre-requistite of scientific progress ... Let reconciliations proceed.  - W.V.O Quine in _Word and Object_\n",
        "\n",
        "Another observation in a similar vein is that penalised spline models are provably [equivalent](https://www.tjmahr.com/random-effects-penalized-splines-same-thing/) to hierarchical regression (random effects) models. This is striking because the character of these types of model seems diametrically opposed. With spline models you jerry-rig your features to an optimisation goal, with hierarchical model you tend to impose theoretical structure to induce shrinkage. It's hard to see how this would work? With a penalised spline model are you inducing a hierarchy of latent features you can't name? Should you even try to translate between the two!? How can we leverage our prior knowledge of the data generating process to add structure to spline model predictions?\n",
        "\n",
        "The abstract components of our model are less graspable than their predictive performance yet the qualitative character of theory buiding differs markedly between these abstractions and aesthetics and explainability feature heavily in model preference. Next we'll add another layer to our abstractions and show how to use hierarchical modelling over spline fits can be used to extract insight into the data generating process over a family of curves. In particular we'll focus on the development of insurance loss curves and how to constrain our predictions within reasonable bounds. This is an apt problem for spline modelling in that the process is repeatable annually, but the domain of the support i.e. development in time is fixed year-on-year so the extrapolation problem is muted. \n",
        "\n",
        "## Insurance Loss Curves: Hierarchical Spline Models\n",
        "\n",
        "__Hierarchical models of spline fits allow us to characterise and sample from fits over a family of curves while improving out of sample predictive accuracy.__ We draw on car insurance losses data set discussed in Mick Cooney's Stan case-study, but we simplify things for ourselves considerably by focusing on two types of loss and ensuring that each year under consideration has equal observations of the accruing losses. \n"
      ],
      "id": "6bc58d1d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "loss_df = pd.read_csv('ppauto_pos.csv')\n",
        "loss_df = loss_df[(loss_df['GRCODE'].isin([43, 353])) & (loss_df['DevelopmentYear'] < 1998)]\n",
        "\n",
        "loss_df = loss_df[['GRCODE', 'AccidentYear', 'DevelopmentYear', 'DevelopmentLag', 'EarnedPremDIR_B', 'CumPaidLoss_B']]\n",
        "\n",
        "\n",
        "loss_df.columns = ['grcode', 'acc_year', 'dev_year', 'dev_lag', 'premium', 'cum_loss']\n",
        "loss_df['lr'] = loss_df['cum_loss'] / loss_df['premium']\n",
        "loss_df = loss_df[(loss_df['acc_year'] <= 1992) & (loss_df['dev_lag'] <= 6)].reset_index(drop=True)\n",
        "\n",
        "loss_df['year_code'] = loss_df['acc_year'].astype(str) + '_' + loss_df['grcode'].astype(str)\n",
        "loss_df.sort_values(by=['year_code', 'acc_year', 'dev_lag'], inplace=True)\n",
        "loss_df['standardised_premium'] = (loss_df.assign(mean_premium = np.mean(loss_df['premium']))\n",
        ".assign(std_premium = np.std(loss_df['premium']))\n",
        ".apply(lambda x: (x['mean_premium'] - x['premium']) /x['std_premium'], axis=1)\n",
        ")\n",
        "\n",
        "loss_df.head(12)"
      ],
      "id": "53971194",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Plot the Loss Curves\n",
        "Here we have plotted the developing loss curves from two different coded insurance products. \n"
      ],
      "id": "e205b36d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pivot = loss_df.pivot(index=['dev_lag'], columns=['grcode', 'acc_year'], values='lr')\n",
        "fig, axs = plt.subplots(1, 2, figsize=(9, 7))\n",
        "pivot.plot(figsize=(10, 6), ax=axs[0])\n",
        "axs[0].set_title(\"Loss Ratios by Year\");\n",
        "for c in pivot.columns:\n",
        "    if 43 in c:\n",
        "        color='red'\n",
        "    else: \n",
        "        color='grey'\n",
        "    axs[1].plot(pivot[c], color=color, label=c)\n",
        "axs[1].legend()\n",
        "axs[1].set_title(\"Loss Ratio by Group\");\n"
      ],
      "id": "4c917729",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We want to model these curves collectively as instances of draws from a distribution of loss curves. To do so we will specify a `PyMC` hierarchical (mixed) spline model. To do so we will have a spline basis for the global hyper parameters `beta_g` and the individual parameters for each curve. Here we define a convenience function to generate the basis splines. \n"
      ],
      "id": "5af92971"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def make_basis_splines(num_knots=3, max_dev=7):\n",
        "    knot_list = np.linspace(0, max_dev, num_knots+2)[1:-1]\n",
        "    dev_periods = np.arange(1, max_dev, 1)\n",
        "\n",
        "    Bi = dmatrix(\n",
        "        \"bs_patsy(dev_periods, knots=knots, degree=3, include_intercept=True) - 1\",\n",
        "        {\"dev_periods\": dev_periods, \"knots\": knot_list},\n",
        "    )\n",
        "\n",
        "    Bg = dmatrix(\n",
        "        \"bs_patsy(dev_periods, knots=knots, degree=3, include_intercept=True) - 1\",\n",
        "        {\"dev_periods\": dev_periods, \"knots\": knot_list})\n",
        "\n",
        "\n",
        "    return Bi, Bg\n",
        "\n",
        "Bi, Bg = make_basis_splines()\n",
        "Bg"
      ],
      "id": "b819c06b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next we specify a model maker function to create the various pooled, unpooled and hierarhical (mixed) models of the insurance curve data. Note that even though we're specifying a hierarhical model we have not specified a hierarchy over the insurance codes, instead we have added this as a \"fixed\" effect feature into our regression model. The idea is that this fixed effect will capture the differences in expected baseline per group code of insurance product. \n"
      ],
      "id": "6b0eb571"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "\n",
        "def make_model(loss_df, num_knots=3, max_dev=7, model_type='mixed'):\n",
        "    Bi, Bg = make_basis_splines(num_knots, max_dev)\n",
        "    observed = loss_df['lr'].values\n",
        "    uniques, unique_codes = pd.factorize(loss_df['year_code'])\n",
        "    coords= {'years': unique_codes, \n",
        "            'splines': list(range(Bi.shape[1])) ,\n",
        "            'measurement': list(range(6)), \n",
        "            'obs': uniques\n",
        "            }\n",
        "\n",
        "    with pm.Model(coords=coords) as sp_insur:\n",
        "        basis_g = pm.MutableData('Bg', np.asfortranarray(Bg))\n",
        "\n",
        "        tau = pm.HalfCauchy('tau', 1)\n",
        "        ## Global Hierarchical Spline Terms\n",
        "        beta_g = pm.Normal(\"beta_g\", mu=0, sigma=tau, \n",
        "        dims='splines')\n",
        "        mu_g = pm.Deterministic(\"mu_g\", pm.math.dot(basis_g, beta_g), dims='measurement')\n",
        "\n",
        "        ## Individual or Year Specific Spline Modifications\n",
        "        if model_type in ['mixed', 'unpooled']:\n",
        "            sigma = pm.HalfCauchy('sigma_i', 1)\n",
        "            basis_i = pm.MutableData('Bi', np.asfortranarray(Bi))\n",
        "            beta = pm.Normal(\"beta\", mu=0, sigma=sigma, dims=('splines', 'years'))\n",
        "            mui = pm.Deterministic(\"mui\", pm.math.dot(basis_i, beta), dims=('measurement', 'years'))\n",
        "        \n",
        "        ## Features\n",
        "        prem = pm.MutableData('prem', loss_df['standardised_premium'].values)\n",
        "        grcode = pm.MutableData('grcode', loss_df['grcode'] == 43)\n",
        "\n",
        "        beta_prem = pm.Normal('beta_prem', 0, 1)\n",
        "        beta_grcode = pm.Normal('beta_grcode', 0, 1)\n",
        "        mu_prem = beta_prem*prem\n",
        "        mu_grcode = beta_grcode*grcode\n",
        "\n",
        "        ## Likelihood\n",
        "        sigma = pm.TruncatedNormal(\"sigma\", 1, lower=0.005)\n",
        "        if model_type == 'mixed':\n",
        "            mu = pm.Deterministic('mu',  mu_grcode + mu_prem + (mu_g.T + mui.T).ravel(), dims='obs')\n",
        "            lr_likelihood = pm.Normal(\"lr\", mu, sigma, observed=observed, dims=('obs'))\n",
        "        elif model_type == 'pooled': \n",
        "             lr_likelihood = pm.Normal(\"lr\",  np.repeat(mu_g, len(unique_codes)), sigma, observed=observed, dims='obs')\n",
        "        elif model_type == 'unpooled':\n",
        "            lr_likelihood = pm.Normal(\"lr\",  mui.T.ravel(), sigma, observed=observed, dims=('obs'))\n",
        "\n",
        "\n",
        "        ## Sampling\n",
        "        idata_sp_insur = pm.sample(2000, return_inferencedata=True, target_accept=.99,\n",
        "        idata_kwargs={\"log_likelihood\": True})\n",
        "        idata_sp_insur = pm.sample_posterior_predictive(\n",
        "            idata_sp_insur,extend_inferencedata=True)\n",
        "\n",
        "    return idata_sp_insur, sp_insur\n",
        "\n",
        "\n",
        "idata_sp_insur_unpooled, sp_insur_unpooled = make_model(loss_df, model_type='unpooled')\n",
        "idata_sp_insur_pooled, sp_insur_pooled = make_model(loss_df, model_type='pooled')\n",
        "idata_sp_insur_mixed, sp_insur_mixed = make_model(loss_df, model_type='mixed')"
      ],
      "id": "6ba7faf4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The model structure can be seen more clearly in this graph. The important features to note are the spline components and the manner of their combination. We are postulating a kind of hierarchy of development curves. We specify the \"global\" curve in 7 development steps and allow that each distinct year is a realisation of a curve that can be thought of as modifying the profile of \"global\" curve as `mui` is combined with `mu_g`. These structures are then combined into a more traditional regression and fed into our likelihood term.  \n"
      ],
      "id": "50155967"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pm.model_to_graphviz(sp_insur_mixed)\n"
      ],
      "id": "49f0e95c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can extract the effect of the differences grcodes and examine the baseline and annual spline related coefficients. \n"
      ],
      "id": "29fdcdda"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "summary = az.summary(idata_sp_insur_mixed, var_names=['sigma', 'beta_grcode', 'beta_prem', 'beta_g', 'beta'])\n",
        "\n",
        "summary"
      ],
      "id": "22210b3c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Again we can compare the performance metrics of the various models. \n"
      ],
      "id": "3bd026bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "compare_df = az.compare({'unpooled': idata_sp_insur_unpooled, \n",
        "            'pooled': idata_sp_insur_pooled, \n",
        "            'mixed': idata_sp_insur_mixed})\n",
        "\n",
        "az.plot_compare(compare_df)\n",
        "compare_df"
      ],
      "id": "4510926e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The hierarchical splne model is by far the best fit to our data. What does it represent? Yes, splines are function approximation tools. Sure, extrapolation is dangerous, but in this domain where the range of the development curves is constrained they seem to offer an elegant way of articulating the structure of the risk profiles for various products.\n",
        "\n",
        "### Plot the Posterior Predictive Checks\n",
        "\n",
        "We can check how well the model can recapture the observed data.\n"
      ],
      "id": "93907558"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_ppc_splines(idata):\n",
        "    fig, axs = plt.subplots(2, 5, figsize=(20, 10), sharey=True)\n",
        "    axs = axs.flatten()\n",
        "    dev_periods = np.arange(1, 7, 1)\n",
        "    uniques, unique_codes = pd.factorize(loss_df['year_code'])\n",
        "    for y, c in zip(unique_codes, range(10)):\n",
        "        az.plot_hdi(dev_periods, idata['posterior_predictive']['lr'].sel(obs=c), color='firebrick', ax=axs[c], fill_kwargs={'alpha': 0.2}, hdi_prob=.89)\n",
        "        az.plot_hdi(dev_periods, idata['posterior_predictive']['lr'].sel(obs=c), color='firebrick', ax=axs[c], hdi_prob=0.5)\n",
        "        axs[c].scatter(dev_periods, loss_df[(loss_df['year_code'] == y)]['lr'], color='k', label='Actual Loss Ratio')\n",
        "        axs[c].plot(dev_periods, loss_df[(loss_df['year_code'] == y)]['lr'], color='k')\n",
        "        axs[c].set_title(f\"PPC 89% and 50% HDI: {y}\")\n",
        "        axs[c].set_ylabel(\"Loss Ratio\")\n",
        "        axs[c].legend();\n",
        "\n",
        "plot_ppc_splines(idata_sp_insur_mixed);"
      ],
      "id": "d3e2d85c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Plot the Hierarchical Components\n",
        "\n",
        "In the following plot we show similarly how to recapture the observed data, but additionally we can decompose the structure of the model in each case and extract baseline forecasts which would be our guide to future loss-ratio development curves in lieu of any other information. \n"
      ],
      "id": "7644d55b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "mu_g = idata_sp_insur_mixed.posterior.stack(draws=(\"chain\", \"draw\"))[\"mu_g\"]\n",
        "\n",
        "mu_i = idata_sp_insur_mixed.posterior.stack(draws=(\"chain\", \"draw\"))[\"mui\"]\n",
        "\n",
        "mu  = idata_sp_insur_mixed.posterior.stack(draws=(\"chain\", \"draw\"))['mu']\n",
        "\n",
        "beta_grcode = idata_sp_insur_mixed.posterior.stack(draws=(\"chain\", \"draw\"))['beta_grcode']\n",
        "\n",
        "dev_periods = np.arange(1, 7, 1)\n",
        "uniques, unique_codes = pd.factorize(loss_df['year_code'])\n",
        "\n",
        "mosaic = \"\"\"\n",
        "         ABCDE\n",
        "         FGHIJ\n",
        "         KKKKK\n",
        "\"\"\"\n",
        "fig, axs = plt.subplot_mosaic(mosaic, sharey=True, \n",
        "figsize=(20, 15))\n",
        "axs = [axs[k] for k in axs.keys()] \n",
        "\n",
        "mu_g_mean = mu_g.mean(dim='draws')\n",
        "for y, c in zip(unique_codes, range(10)):\n",
        "    group_effect = 0\n",
        "    if '43' in y: \n",
        "        group_effect = beta_grcode.mean().item()\n",
        "    mu_i_mean = mu_i.sel(years=y).mean(dim='draws')\n",
        "    axs[c].plot(dev_periods, group_effect + mu_g_mean.values + mu_i_mean.values, label='Combined + E(grp_effect)', color='purple', linewidth=3.5)\n",
        "    axs[c].plot(dev_periods, group_effect + mu_g_mean.values, label='E(Hierarchical Baseline)', color='red', linestyle='--')\n",
        "    axs[c].plot(dev_periods,  group_effect + mu_i_mean.values, label='E(Year Specific Adjustment)', color='blue', linestyle='--')\n",
        "    axs[c].scatter(dev_periods, loss_df[(loss_df['year_code'] == y)]['lr'], color='k', label='Actual Loss Ratio')\n",
        "    az.plot_hdi(dev_periods,mu.sel(obs=c).T  , ax=axs[c], color='firebrick', fill_kwargs={'alpha': 0.2})\n",
        "    az.plot_hdi(dev_periods, mu.sel(obs=c).T , ax=axs[c], color='firebrick', fill_kwargs={'alpha': 0.5}, hdi_prob=.50)\n",
        "    axs[c].set_title(f\"Components for Year {y}\")\n",
        "    axs[c].set_ylabel(\"Loss Ratio\")\n",
        "    if (c == 0):\n",
        "         axs[c].legend()\n",
        "\n",
        "axs[10].plot(dev_periods, mu_g_mean.values, label='E(Hierarchical Baseline)', color='black')\n",
        "axs[10].plot(dev_periods, mu_g_mean.values + group_effect, label='E(Hierarchical Baseline) + E(grp_effect)', color='black', linestyle='--')\n",
        "az.plot_hdi(dev_periods, mu_g.T.values, color='slateblue', ax=axs[10], fill_kwargs={'alpha': 0.2})\n",
        "az.plot_hdi(dev_periods, mu_g.T.values + group_effect, color='magenta', ax=axs[10], fill_kwargs={'alpha': 0.2})\n",
        "az.plot_hdi(dev_periods, mu_g.T.values, color='slateblue', ax=axs[10], hdi_prob=.5)\n",
        "az.plot_hdi(dev_periods, mu_g.T.values  + group_effect, color='magenta', ax=axs[10], hdi_prob=.5)\n",
        "axs[10].set_title(\"Baseline Forecast Loss Ratio\")\n",
        "axs[10].legend();\n"
      ],
      "id": "e70f9fde",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This plot is a bit clunky, because we're mixing expectations and posterior distributions over the parameters. The point is just to highlight the \"compositional\" structure of our model.\n",
        "\n",
        "### Predicting Next Year's Losses\n",
        "\n",
        "A better way to interrogate the implications of the model is to \"push\" forward different data through the posterior predictive distribution and derive a kind of ceteris paribus rule for accrual of losses.\n"
      ],
      "id": "c112d6b6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "with sp_insur_mixed: \n",
        "    pm.set_data({'grcode': np.ones(len(loss_df)), \n",
        "    })\n",
        "    idata_43 = pm.sample_posterior_predictive(idata_sp_insur_mixed, var_names=['lr'], extend_inferencedata =True)\n",
        "\n",
        "with sp_insur_mixed: \n",
        "    pm.set_data({'grcode': np.zeros(len(loss_df))})\n",
        "    idata_353 = pm.sample_posterior_predictive(idata_sp_insur_mixed, var_names=['lr'], extend_inferencedata=True)\n",
        "\n",
        "idata_353"
      ],
      "id": "f69baa77",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Even here though we want to average the curves over the specific years in the data and abstract a view of the model implications under different counterfactual settings. Or put another way, we want a view of the average development curve between years, not within a year. If we want to predict the novel insurance loss for next year we need some way to aggregate between the annual trajectories. Here we define a helper function to effect this step. \n"
      ],
      "id": "e658602f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def get_posterior_predictive_curve(idata, prem=2, grcode=1):\n",
        "    weighted_splines = [np.dot(np.asfortranarray(Bi), az.extract(idata['posterior']['beta'])['beta'].values[:, :, i]) for i in range(2000)]\n",
        "\n",
        "    weighted_splines_1 = [np.dot(np.asfortranarray(Bg), az.extract(idata['posterior']['beta_g'])['beta_g'].values[:, i]) for i in range(2000)]\n",
        "\n",
        "    beta_grcode = az.extract(idata['posterior']['beta_grcode'])['beta_grcode']\n",
        "\n",
        "    beta_prem = az.extract(idata['posterior']['beta_prem'])['beta_prem']\n",
        "    df1 = pd.DataFrame([beta_prem.values[i]*prem + beta_grcode.values[i]*grcode for i in range(2000)]).T\n",
        "\n",
        "\n",
        "    ## How do we averaging over the years to get\n",
        "    ## a view of a new development period?\n",
        "    #df = pd.concat([pd.DataFrame(weighted_splines_1[i].T + weighted_splines[i].T).mean() for i in range(1000)], axis=1)\n",
        "\n",
        "    ## Sample random group each draw from posterior\n",
        "    df = pd.concat([pd.DataFrame((weighted_splines_1[i].T + weighted_splines[i].T)[np.random.choice(list(range(10))), :]) for i in range(2000)], axis=1)\n",
        "\n",
        "    ## Average random subset of of groups\n",
        "    #df = pd.concat([pd.DataFrame((weighted_splines_1[i].T + weighted_splines[i].T)[np.random.choice(list(range(10)), 5), :]).mean() for i in range(2000)], axis=1)\n",
        "\n",
        "    df = df1.iloc[0].values + df\n",
        "\n",
        "    return df\n",
        "\n",
        "pred_df_1 = get_posterior_predictive_curve(idata_43, prem=1, grcode=1)\n",
        "pred_df_0 = get_posterior_predictive_curve(idata_353, prem=1, grcode=0) \n",
        "\n",
        "fig, ax = plt.subplots(figsize=(9, 7), sharey=True)\n",
        "\n",
        "az.plot_hdi(range(6), pred_df_0.values.T, ax=ax, color='slateblue', smooth=False, fill_kwargs={'alpha': 0.2})\n",
        "az.plot_hdi(range(6), pred_df_1.values.T, ax=ax, color='firebrick', smooth=False, fill_kwargs={'alpha': 0.2})\n",
        "az.plot_hdi(range(6), pred_df_0.values.T, ax=ax, color='slateblue', smooth=False, fill_kwargs={'alpha': 0.5}, hdi_prob=.5)\n",
        "az.plot_hdi(range(6), pred_df_1.values.T, ax=ax, color='firebrick', smooth=False, fill_kwargs={'alpha': 0.5}, hdi_prob=.5)\n",
        "ax.plot(pred_df_0.mean(axis=1), linestyle='-', color='k', linewidth=4, label='grcode 353 prem 1')\n",
        "\n",
        "ax.plot(pred_df_1.mean(axis=1), linestyle='--', color='grey', linewidth=4, label='grcode 43 prem 1')\n",
        "\n",
        "ax.set_title(\"Posterior Samples of the Trajectories \\n Under different Counterfactual settings\")\n",
        "ax.set_ylabel(\"Loss Ratio\")\n",
        "ax.set_xlabel(\"Development Period\")\n",
        "ax.legend();"
      ],
      "id": "06e88449",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note how we've varied the predictor inputs to showcase the expected realisation under different product codes. In this manner we can construct a hierarchical spline model with informed by the historic trajectories of the development curves but with predictions modulated by more recent information.  \n",
        "\n",
        "## Multiple Smoother Regression Models\n",
        "\n",
        "__Non-linear spline relationships can be additively combined across multiple variables in simple and hierarchical regressions.__ To demonstrate how spline modelling can be further adapted to the multiple regression like cases we use the PISA data set discussed in [this case study](https://m-clark.github.io/generalized-additive-models/application.html) from Michael Clark. We'll see how crucial it is to carefully assess the implications of these model fits. \n",
        "\n",
        "The data set has been constructed using average Science scores by country from the Programme for International Student Assessment (PISA) 2006, along with GNI per capita (Purchasing Power Parity, 2005 dollars), Educational Index, Health Index, and Human Development Index from UN data. We want to model the overall outcome score as a function of these broad demographic features. \n"
      ],
      "id": "05157b87"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pisa_df = pd.read_csv(\"https://raw.githubusercontent.com/m-clark/generalized-additive-models/master/data/pisasci2006.csv\")\n",
        "\n",
        "pisa_df.head()\n"
      ],
      "id": "99550273",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The relationships displayed between each of these measures is not obviously linear, and as such could plausibly benefit from being modelled with splines. \n"
      ],
      "id": "bb8fe2c5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g = sns.pairplot(pisa_df[['Overall', 'Income', 'Support', 'Health', 'Edu']],  kind=\"reg\", height=1.5)\n",
        "g.fig.suptitle(\"Pair Plot of Complex Relations\", y=1.05);"
      ],
      "id": "bc13a50a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define three models for contrasting the implications. Note here how we have to define a seperate spline basis for each of the covariates. Here we create the knots for defining our basis on each covariate. \n"
      ],
      "id": "c23a948b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "knots_income = np.linspace(np.min(pisa_df['Income']), np.max(pisa_df['Income']), 5+2)[1:-1]\n",
        "\n",
        "knots_edu = np.linspace(np.min(pisa_df['Edu']), np.max(pisa_df['Edu']), 5+2)[1:-1]\n",
        "\n",
        "knots_health = np.linspace(np.min(pisa_df['Health']), np.max(pisa_df['Health']), 5+2)[1:-1]\n",
        "\n",
        "knots_income1 = np.linspace(np.min(pisa_df['Income']), np.max(pisa_df['Income']), 3+2)[1:-1]\n",
        "\n",
        "knots_edu1 = np.linspace(np.min(pisa_df['Edu']), np.max(pisa_df['Edu']), 3+2)[1:-1]\n",
        "\n",
        "knots_health1 = np.linspace(np.min(pisa_df['Health']), np.max(pisa_df['Health']), 3+2)[1:-1]"
      ],
      "id": "822fc8d5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we initialise these models\n"
      ],
      "id": "c4569d05"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "formula = \"Overall ~ Income + Edu + Health\"\n",
        "base_model = bmb.Model(formula, pisa_df, dropna=True)\n",
        "\n",
        "formula_spline = \"\"\"Overall ~ bs(Income, degree=3, knots=knots_income) + bs(Edu, degree=3, knots=knots_edu) + bs(Health, degree=3, knots=knots_health) \"\"\"\n",
        "\n",
        "formula_spline1 = \"\"\"Overall ~ (1 | Country) + bs(Income, degree=3, knots=knots_income1) + bs(Edu, degree=3, knots=knots_edu1) + bs(Health, degree=3, knots=knots_health1) \"\"\"\n",
        "\n",
        "spline_model = bmb.Model(formula_spline, pisa_df, dropna=True)\n",
        "\n",
        "spline_model1 = bmb.Model(formula_spline1, pisa_df, dropna=True)\n",
        "\n",
        "spline_model1"
      ],
      "id": "febf7128",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "spline_model.build()\n",
        "spline_model.graph()"
      ],
      "id": "5a80974e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| \n",
        "base_idata = base_model.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True})\n",
        "spline_idata = spline_model.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True}, target_accept=.95)\n",
        "spline_idata1 = spline_model1.fit(random_seed=random_seed, idata_kwargs={\"log_likelihood\": True}, target_accept=.99)"
      ],
      "id": "f6593b5a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can compare the simple regression approach to the spline based regression in the now usual way. \n"
      ],
      "id": "e0088319"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "compare_df = az.compare({'spline': spline_idata, 'raw': base_idata, 'spline_hierarchy':spline_idata1})\n",
        "\n",
        "compare_df\n"
      ],
      "id": "65dd5433",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The coefficients comparisons are harder\n"
      ],
      "id": "a612edef"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(base_idata)"
      ],
      "id": "130d3218",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "since it's less clear what the spline coefficient terms mean. \n"
      ],
      "id": "01b98319"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "az.summary(spline_idata)"
      ],
      "id": "b1781286",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can also check that the model seems to recover the observed data well. \n",
        "\n",
        "### Plotting Posterior Predictive Checks\n"
      ],
      "id": "d914ae9e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "base_model.predict(base_idata, kind='pps')\n",
        "spline_model.predict(spline_idata, kind='pps')\n",
        "spline_model1.predict(spline_idata1, kind='pps')\n",
        "\n",
        "\n",
        "fig, axs = plt.subplots(1, 3, figsize=(20, 6))\n",
        "axs = axs.flatten()\n",
        "az.plot_ppc(base_idata, ax=axs[0])\n",
        "az.plot_ppc(spline_idata, ax=axs[1]);\n",
        "az.plot_ppc(spline_idata1, ax=axs[2]);\n",
        "axs[0].set_xlabel('')\n",
        "axs[1].set_title(\"PPC: Spline Model\");\n",
        "axs[0].set_title(\"PPC: Regression Model\");\n",
        "axs[2].set_title(\"PPC: Hierarchical Spline Model\");"
      ],
      "id": "1956d742",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next we'll dig into the spline basis features and decompose the predicted outcome and show how the outcome varies for levels in the inputs variables. The Bambi interpret package offers some functionality to assess the conditional predictions for varying values of the input variables. \n",
        "\n",
        "### Model Interpretability Plots in Bambi\n",
        "\n",
        "We want to highlight the differences between the hierarchical and non-hierarchical multivariable spline models here. The shrinkage effects of hierarchically modelling the country intercepts is clearly evident. They helpfully constrain the poor extrapolation effects of the simpler spline model.\n"
      ],
      "id": "3874a562"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, axs = plt.subplots(3, 2, figsize=(9, 14))\n",
        "axs = axs.flatten()\n",
        "bmb.interpret.plot_predictions(\n",
        "    spline_model, spline_idata, \"Income\", ax=axs[0]\n",
        ")\n",
        "\n",
        "axs[0].set_title(\"Non-Hierarchical Income\")\n",
        "axs[2].set_title(\"Non-Hierarchical Edu\")\n",
        "axs[4].set_title(\"Non-Hierarchical Health\")\n",
        "\n",
        "axs[1].set_title(\"Hierarchical Income\")\n",
        "axs[3].set_title(\"Hierarchical Edu\")\n",
        "axs[5].set_title(\"Hierarchical Health\")\n",
        "\n",
        "\n",
        "bmb.interpret.plot_predictions(\n",
        "    spline_model, spline_idata, \"Edu\", ax=axs[2]\n",
        ")\n",
        "\n",
        "bmb.interpret.plot_predictions(\n",
        "    spline_model, spline_idata, \"Health\", ax=axs[4]\n",
        ");\n",
        "\n",
        "bmb.interpret.plot_predictions(\n",
        "    spline_model1, spline_idata1, \"Income\", \n",
        "    sample_new_groups=True, ax=axs[1]\n",
        ")\n",
        "\n",
        "bmb.interpret.plot_predictions(\n",
        "    spline_model1, spline_idata1, \"Edu\", sample_new_groups=True, ax=axs[3]\n",
        ")\n",
        "\n",
        "bmb.interpret.plot_predictions(\n",
        "    spline_model1, spline_idata1, \"Health\",sample_new_groups=True, ax=axs[5]\n",
        ");\n"
      ],
      "id": "3b924631",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can pull these types of values out into a table. Note here how we ask for predictions based on varying values of the `Edu` and `Income` variables where we keep the `Health` variable fixed at the mean value. \n"
      ],
      "id": "3857fba5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "summary_df = bmb.interpret.predictions(\n",
        "    spline_model,\n",
        "    spline_idata,\n",
        "    conditional={\n",
        "        \"Edu\": list(np.linspace(0.5, .95, 10)),\n",
        "        \"Income\": list(np.linspace(0.4, .95, 10)),\n",
        "        },\n",
        ")\n",
        "summary_df\n",
        "\n",
        "\n",
        "summary_df1 = bmb.interpret.predictions(\n",
        "    spline_model1,\n",
        "    spline_idata1,\n",
        "    conditional={\n",
        "        \"Edu\": list(np.linspace(0.5, .95, 10)),\n",
        "        \"Income\": list(np.linspace(0.4, .95, 10)),\n",
        "        },\n",
        "    sample_new_groups=True\n",
        ")\n",
        "summary_df1\n"
      ],
      "id": "5ff0975a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can then plot these results based on the conditional realisations and see some interesting behaviour at the implausilble reaslisations. This should make us somewhat wary of using this model to extrapolate too far beyond the observable range of data\n"
      ],
      "id": "71b0c598"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g = sns.relplot(data=summary_df, x=\"Income\", y=\"estimate\", hue=\"Edu\")\n",
        "\n",
        "g.fig.suptitle(\"Marginal Predictions of the Outcome Variable \\n conditional on counterfactual values for Edu and Income\", y=1.05);\n",
        "\n",
        "\n",
        "g = sns.relplot(data=summary_df1, x=\"Income\", y=\"estimate\", hue=\"Edu\")\n",
        "\n",
        "g.fig.suptitle(\"Hierarchical Marginal Predictions of the Outcome Variable \\n conditional on counterfactual values for Edu and Income\", y=1.05);"
      ],
      "id": "a888bf70",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "However, we can see here how the hierarchical component shrinks the predicted values back towards a reasonable range! Constraining the poor extrapolation of the more naive spline model. This demonstrates something of the interplay between in-sample approximation and out of sample generalisation we saw above in the case of the insurance curve development. The additional structure insists on commensurate realisations under different counterfactual settings reflective of the fact that countries do not vary so radically. \n",
        "\n",
        "### The Spline Component Contributions\n",
        "\n",
        "Finally, we'll pull out the component contributions of each variable and see how they combine additively. This will also serve as a kind of posterior predictive check for each country as we can show the degree which posterior draws from each component sum to achieve a plausible mirror of the observed data.  \n"
      ],
      "id": "aa35db9b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "Bincome = spline_model.response_component.design.common['bs(Income, degree=3, knots=knots_income)']\n",
        "\n",
        "income_coefs = az.extract(spline_idata['posterior']['bs(Income, degree=3, knots=knots_income)'])['bs(Income, degree=3, knots=knots_income)']\n",
        "\n",
        "Bedu = spline_model.response_component.design.common['bs(Edu, degree=3, knots=knots_edu)']\n",
        "\n",
        "edu_coefs = az.extract(spline_idata['posterior']['bs(Edu, degree=3, knots=knots_edu)'])['bs(Edu, degree=3, knots=knots_edu)']\n",
        "\n",
        "\n",
        "Bhealth = spline_model.response_component.design.common['bs(Health, degree=3, knots=knots_health)']\n",
        "\n",
        "health_coefs = az.extract(spline_idata['posterior']['bs(Health, degree=3, knots=knots_health)'])['bs(Health, degree=3, knots=knots_health)']\n",
        "\n",
        "income = np.dot(Bincome, income_coefs).T \n",
        "edu = np.dot(Bedu, edu_coefs).T\n",
        "health = np.dot(Bhealth, health_coefs).T\n",
        "\n",
        "intercept = az.extract(spline_idata['posterior']['Intercept'])['Intercept'].values\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 7))\n",
        "for i in range(100):\n",
        "    if i == 1:\n",
        "        ax.plot(income[i], label='Income Component', color='red')\n",
        "        ax.plot(edu[i], label='Edu Component', color='blue')\n",
        "        ax.plot(health[i], label='Health Component', color='darkgreen')\n",
        "        ax.plot(intercept[i] + income[i] + edu[i] + health[i], label='Combined Components', color='purple')\n",
        "    else: \n",
        "        ax.plot(income[i], alpha=0.1, color='red')\n",
        "        ax.plot(edu[i], alpha=0.1, color='blue')\n",
        "        ax.plot(health[i], alpha=0.1, color='darkgreen')\n",
        "        ax.plot(intercept[i] + income[i] + edu[i] + health[i], color='purple', alpha=0.3)\n",
        "\n",
        "ax.scatter(range(len(spline_idata['observed_data']['Overall'])), spline_idata['observed_data']['Overall'], label='Observed', color='grey', s=56, ec='black')\n",
        "ax.set_title(\"PISA Outcomes \\n Additive Spline Components\", fontsize=20)\n",
        "ax.legend();\n",
        "ax.set_ylabel(\"Overall Score\", fontsize=12)\n",
        "ax.set_xticklabels(pisa_df.dropna(axis=0).reset_index()['Country'], fontsize=12);"
      ],
      "id": "5b41f597",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can see here how the combined components borrow the structure of the outcome variable primarily from the income variable component. The health measures have closer to zero additive contribution while the uncertainty in the educational component varies wildly. But the blue educational component here is used primarily as a scaling contribution which adds to the level of the outcome variable rather than distorting the shape. These initially opaque synthetic features of splines can offer deep insight into the structure of our data generating process when seen correctly. \n",
        "\n",
        "## Conclusion\n",
        "\n",
        "We've seen the application of splines as univariate smoothers to approximate wiggly curves of arbitrary shape. We've also tried gaussian process approximations of the same univariate functions. The suggested flexibility of both methods is a strength, but we need to be careful where splines have a tendency to over-fit to individual curves. As such we have tried to show that we can incorporate spline basis modelling in a hierarchical bayesian model and recover more compelling posterior predictive checks and additionally derive predictiions from the mixed variant of the hierarhical model which helps us understand the implications of the data for generic forecasts of insurance loss curves. Finally we showed how splines can be used additively to model non-linear functions of multiple covariates. These are a powerful tool to interrogate complex non-linear relationships, but they offer interpolation of functions within a well understood domain. Applealing to these models for extrapolation needs to be done carefully. \n",
        "\n",
        "We can, I think, draw a broad moral from this presentation. Observed phenomena admit description with a wide variety of mathematical abstraction. The \"correctness\" of the abstraction is never the right question. The manner in which one abstraction distils the structure of reality is not fundamentally any better than the manner in which an alternative scheme will do so. Predictive success achieved applying one abstraction can be traded off for interpretive tractability in another. What matters is the task at hand - solving the problem. Sometimes problems can be solved with new information, but mostly they're resolved by re-arranging assumptions and phrasing the problem anew - seeing through a different lens, pulling the door handle where we previously pushed. Splines, hierarhical splines and gaussian process models all attempt to approximate an answer by rephrasing the question. The more of these tools we have, the better we are prepared to tackle novel problems and discern the pertinent structure in the world. "
      ],
      "id": "d1a58c4b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "pymc_causal",
      "language": "python",
      "display_name": "pymc_causal",
      "path": "/Users/nathanielforde/Library/Jupyter/kernels/pymc_causal"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}