---
title: "Measurement, Latent Factors and the Garden of Forking Paths"
subtitle: "Confirmatory Factor Analysis and Structural Equations in PyMC"
categories: ["cfa", "sem", "measurment"]
keep-ipynb: true
self-contained: true
draft: false
toc: true
execute: 
  freeze: auto 
  execute: true
jupyter: pymc_causal
image: 'forking_paths.jpg'
engine: knitr
author:
    - url: https://nathanielf.github.io/
    - affiliation: PyMC dev
citation: true
---

```{r}
#| warning: false
#| 
library(lavaan)
library(dplyr)
library(reticulate)
library(marginaleffects)
library(modelsummary)
library(ggplot2)
library(tidyr)
library(egg)
library(lme4)
library(semPlot)
library(tinytable)
library(kableExtra)
library(reshape2)
reticulate::py_run_string("import pymc as pm")

options(rstudio.python.installationPath = "/Users/nathanielforde/mambaforge/envs")
options("modelsummary_factory_default" = "tinytable")
options(repr.plot.width=15, repr.plot.height=8)

knitr::knit_engines$set(python = reticulate::eng_python)
options(scipen=999)
set.seed(130)
```

::: callout-note
Choices are made as we step down the garden of forking paths in the course of any analysis. Often, in the process of frantic search we cling too strongly to the first feasible path. This risks delusion from directionless flailing and simple [satisficing](https://en.wikipedia.org/wiki/Satisficing). Equally problematic, we risk impoverished and inadequate theory if we refuse to explore more paths. In this post we will elaborate this explore/exploit tension when analyzing psychometric survey data. In psychometric theory we must vary the hypothesised structure of our manifest and latent variables - this cannot be done whimsically as we seek better fit to data. There is a trial and error kind of creativity in model development **and** a requirement for rigor when we structure the inferences derivable from our model. We show how these confirmatory and exploratory modes of inference play-out in the Confirmatory Factor Analysis with Structural equations in PyMC under the modern Bayesian workflow.
:::

## Measurement and Measurement Constructs

Science is easier when there is a recipe. When there is some procedure to adopt or routine to ape, you can out-source the responsibility for methodological justification. One egregious pattern in this vein tries to mask implausible nonsense with the mathematical gloss of "statistical significance". Seen from 1000 feet, this is misguided but not surprising. Lip-service is paid to the idea of scientific method and we absolve ourselves of the requirement for principled justification and substantive argument.

Evidence should be marshaled in service to argument. But it's an absurd pretense to claim that data speaks for itself in this argument. Good and compelling argumentation is at the heart of any sound inference. It is a necessary obligation if you expect anyone to make any decision on the strength of evidence you provide. Procedures and routine tests offer only a facsimile of sound argument and p-values are a poor substitute for narrative cogency, logical consequence and substantive derivation.

Data is found, gathered or (maybe even) carefully curated. In all cases there is need for a defensive posture and an argument that the data is fit-for-purpose. Nowhere is this more clear than in psychometrics where the data is often derived from a strategically constructed survey aimed at a particular target phenomena. Some intuited, but not yet measured, concept that arguably plays a role in human action, motivation or sentiment. The relative "fuzziness" of the subject matter in psychometrics has had a catalyzing effect on the methodological rigour sought in the science. Survey designs are agonized over for correct tone and rhythm of sentence structure. Measurement scales are doubly checked for reliability and correctness. Analysis steps are justified and tested under a wealth of modelling routines. Model architectures are defined and refined to better express the hypothesized structures in the data-generating process. We will see how such attention to detail leads to powerful and expressive models that grant us tractability on thorny questions of human affect.

### Structure of Presentation

We aim to follow a an escalating series of model complexity highlighting the variety of choices that go into modeling psychometric survey data, ultimately concluding by demonstrating how to fit *appropriately* complex models in `PyMC`.

-   Exploratory Data Visualization

    -   Pulling out views to try and make the multivariate survey response seem a bit more concrete.

-   Exploratory Regression Models

    -   Highlighting the nature of the representation that is used when we fit this data into a simple regression context. We also discuss how a model is a tool for exploring the data as much as it is a definitive statement about the nature of the relations in our data-set.

-   Interlude on Model Design and Conditional Independence

    -   A brief digression on what we're aiming to do when fit a model to this kind of data. In particular how we need richer structures to articulate the models that can actually answer questions of interest.

-   Expressive Structure: Building the Model we Need

    -   Confirmatory Factor Models in `lavaan`

    -   Structural Equation Models in `lavaan`

    -   Bayesian Confirmatory Factor Models in `PyMC`

    -   Bayesian Structural Equation Models in `PyMC`

Throughout we'll draw on Levy and Mislevy's [*Bayesian Psychometric Modeling*](https://www.taylorfrancis.com/books/mono/10.1201/9781315374604/bayesian-psychometric-modeling-roy-levy-robert-mislevy) to highlight how good model design seeks structures which justify claim(s) of conditional independence; thereby supporting the *argument* to compelling inference.

## The Data

The data is borrowed from work by Boris Mayer and Andrew Ellis found [here](https://methodenlehre.github.io/SGSCLM-R-course/cfa-and-sem-with-lavaan.html#structural-equation-modelling-sem). They demonstrate CFA and SEM modelling with `Lavaan`. We'll load up their data.

```{r}
df = read.csv('sem_data.csv')
df$ls_sum <- df$ls_p1 + df$ls_p2 + df$ls_p3
df$ls_mean <- rowMeans(df[ c('ls_p1', 'ls_p2', 'ls_p3')])

head(df) |> kable() |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")
```

We have survey responses from \~300 individuals who have answered questions regarding their upbringing, self-efficacy and reported life-satisfaction. The hypothetical dependency structure in this life-satisfaction data-set posits a moderated relationship between scores related to life-satisfaction, parental and family support and self-efficacy. It is not a trivial task to be able to design a survey that can elicit answers plausibly mapped to each of these "factors" or themes, never mind finding a model of their relationship that can inform us as to the relative of impact of each on life-satisfaction outcomes.

![Candidate Structure](structural_model.png) We will try to show some of the subtle aspects of these relationships as we go. The high level summary statistics show the variation across these measures. We can thematically cluster them because the source survey deliberately targeted each of the underlying themes in effort to pin down the relations between these hard to measure constructs. We are assuming that our measurement scales are well designed and that the mapping of themes is appropriate.

```{r}

#| code-fold: true
#| code-summary: "Show the code"

datasummary_skim(df)|> 
 style_tt(
   i = 15:17,
   j = 1:1,
   background = "#20AACC",
   color = "white",
   italic = TRUE) |> 
 style_tt(
   i = 18:19,
   j = 1:1,
   background = "#2888A0",
   color = "white",
   italic = TRUE) |> 
 style_tt(
   i = 2:14,
   j = 1:1,
   background = "#17C2AD",
   color = "white",
   italic = TRUE)



```

Note how we've distinguished among the metrics for the "outcome" metrics and the "driver" metrics. Such a distinction may seem trivial, but it is only possible because we bring substantive knowledge to bear on the problem in the design of our survey and the postulation of the theoretical construct. Practically our data is just a multivariate outcome vector. It's theory that offers a structural understanding of how these metrics reflect a dependence. There are a large range of possible interacting effects and the patterns of realization for our life-satisfaction scores. The true "drivers" of satisfaction may be quite different than the hypothesised structure. It is this open question that we're aiming to uncover in the analysis of our survey data. Does our data support the view that parental support is essential to life-satisfaction? To what degree? How do we tease out this implications precisely?

### Sample Covariances and Correlations

To start, let's plot the relations amongst our various indicator scores.

```{r fig.width=10, fig.height=10}

drivers = c('se_acad_p1', 'se_acad_p2', 'se_acad_p3', 'se_social_p1', 'se_social_p2', 'se_social_p3', 'sup_friends_p1','sup_friends_p2', 'sup_friends_p3', 'sup_parents_p1' , 'sup_parents_p2' , 'sup_parents_p3', 'ls_p1', 'ls_p2', 'ls_p3')



plot_heatmap <- function(df, title="Sample Covariances", subtitle="Observed Measures") {
  heat_df = df |> as.matrix() |> melt()
  colnames(heat_df) <- c("x", "y", "value")
  g <- heat_df |> mutate(value = round(value, 2)) |>  ggplot(aes(x = x, y = y, fill = value)) +
    geom_tile() + geom_text(aes(label = value), color = "black", size = 4) +
   scale_fill_gradient2(
      high = 'dodgerblue4',
      mid = 'white',
      low = 'firebrick2'
    ) + theme(axis.text.x = element_text(angle=45)) + ggtitle(title, subtitle)
  
  g
}

g1 = plot_heatmap(cov(df[,  drivers]))

g2 = plot_heatmap(cor(df[,  drivers]), "Sample Correlations")

plot <- ggarrange(g1,g2, ncol=1, nrow=2);

```

Note the relatively strong correlations between measures of parental support and the life-satisfaction outcome `ls_p3`. Similarly, the social self-efficacy scores seem well correlated with the secondary life satisfaction indicator `ls_p2`. These observed correlations merit some further investigation. We can also plot the pairs of scatter plots to "dig deeper". What kind of correlation holds between these scores? Are any driven by extreme outliers? This is what we're looking for in a pair plot. Should we cull the outliers? Leave them in? We leave them in.

### Pair Plots of Multivariate Outcome

```{r fig.width=15, fig.height=15}

df <- df |> 
  mutate(id = row_number()) 

# Prepare data to be plotted on the x axis
x_vars <- pivot_longer(data = df,
             cols = se_acad_p1:ls_p3,
             names_to = "variable_x",
             values_to = "x")

# Prepare data to be plotted on the y axis  
y_vars <- pivot_longer(data = df,
                       cols = se_acad_p1:ls_p3,
                       names_to = "variable_y",
                       values_to = "y") 

# Join data for x and y axes and make plot
full_join(x_vars, y_vars, 
          by = c("id"),
          relationship = "many-to-many") |>
  ggplot() + 
  aes(x = x, y = y) +
  geom_point() + geom_smooth(method='lm') +
  facet_grid(c("variable_x", "variable_y"))  + ggtitle("Pair Plot of Indicator Metrics", 
                                                       "Comparing Against Life Satisfaction Scores")

```

The scatter plots among the highly correlated variables in the heat-map do seem to exhibit some kind of linear relationship with aspects of the life-satisfaction scores. We now turn to modelling these relationships to tease out some kind of inferential summary of those relationships.

## Exploratory Regression Models

To model these effects we make use of the aggregated sum and mean scores to express the relationships between these indicator metrics and life-satisfaction. We fit a variety of models each one escalating in the number of indicator metrics we incorporate into our model of the life-satisfaction outcome. This side-steps the multivariate nature of hypothesised constructs and crudely amalgamates the indicator metrics. This may be more or less justified depending on how similar in theme the three outcome questions `ls_p1, ls_p2, ls_p3` are in nature. We've dodged the question of thematic unity as all our metrics "load equally" on the outcome variable here and we let our regression model sort out the weighting.

```{r}

formula_sum_1st = " ls_sum ~ se_acad_p1  + se_social_p1 +  sup_friends_p1  + sup_parents_p1"
formula_mean_1st = " ls_mean ~ se_acad_p1  + se_social_p1 +  sup_friends_p1  + sup_parents_p1"

formula_sum_12 = " ls_sum ~ se_acad_p1  + se_acad_p2 +  se_social_p1 + se_social_p2 + 
sup_friends_p1 + sup_friends_p2  + sup_parents_p1 + sup_parents_p2"
formula_mean_12 = " ls_mean ~ se_acad_p1  + se_acad_p2 +  se_social_p1 + se_social_p2 + 
sup_friends_p1 + sup_friends_p2  + sup_parents_p1 + sup_parents_p2"


formula_sum = " ls_sum ~ se_acad_p1 + se_acad_p2 + se_acad_p3 + se_social_p1 +  se_social_p2 + se_social_p3 +  sup_friends_p1 + sup_friends_p2 + sup_friends_p3 + sup_parents_p1 + sup_parents_p2 + sup_parents_p3"
formula_mean = " ls_mean ~ se_acad_p1 + se_acad_p2 + se_acad_p3 + se_social_p1 +  se_social_p2 + se_social_p3 +  sup_friends_p1 + sup_friends_p2 + sup_friends_p3 + sup_parents_p1 + sup_parents_p2 + sup_parents_p3"
mod_sum = lm(formula_sum, df)
mod_sum_1st = lm(formula_sum_1st, df)
mod_sum_12 = lm(formula_sum_12, df)
mod_mean = lm(formula_mean, df)
mod_mean_1st = lm(formula_mean_1st, df)
mod_mean_12 = lm(formula_mean_12, df)

norm <- function(x) {
    (x - mean(x)) / sd(x)
}

df_norm <- as.data.frame(lapply(df[c(5:19)], norm))

df_norm$ls_sum <- df$ls_sum
df_norm$ls_mean <- df$ls_mean

mod_sum_norm = lm(formula_sum, df_norm)
mod_mean_norm = lm(formula_mean, df_norm)

models = list(
    "Outcome: sum_score" = list("model_sum_1st_factors" = mod_sum_1st,
     "model_sum_1st_2nd_factors" = mod_sum_12,
     "model_sum_score" = mod_sum,
     "model_sum_score_norm" = mod_sum_norm
     ),
    "Outcome: mean_score" = list(
      "model_mean_1st_factors" = mod_mean_1st,
     "model_mean_1st_2nd_factors" = mod_mean_12,
     "model_mean_score"= mod_mean, 
     "model_mean_score_norm" = mod_mean_norm
    )
    )

```

The classical presentation of regression models reports the coefficient weights accorded to each of the input variables. We present these models to highlight that the manner in which we represent our theoretical constructs has ramifications for the interpretation of the data generating process. In particular, note how different degrees of significance are accorded to the different variables depending on which alternate variables are included.

```{r, class.source = 'fold-hide', fig.width=7}

#| code-fold: true
#| code-summary: "Show the code"

modelsummary(models, stars=TRUE, shape ="cbind") |> 
 style_tt(
   i = 2:25,
   j = 1:1,
   background = "#17C2AD",
   color = "white",
   italic = TRUE)

```

We can similarly plot the coefficient values and their uncertainty highlighting how the representation or scaling of the variables impact the scale of the coefficient weights and therefore the surety of any subsequent claims.

```{r, fig.width=10, fig.height=7}

models = list(
     "model_sum_1st_factors" = mod_sum_1st,
     "model_sum_1st_2nd_factors" = mod_sum_12,
     "model_sum_score" = mod_sum,
     "model_sum_score_norm" = mod_sum_norm,
     "model_mean_1st_factors" = mod_mean_1st,
     "model_mean_1st_2nd_factors" = mod_mean_12,
     "model_mean_score"= mod_mean,
     "model_mean_score_norm" = mod_mean_norm
    )

modelplot(models, coef_omit = 'Intercept') + geom_vline(xintercept = 0, linetype="dotted", 
                color = "black") + ggtitle("Comparing Model Parameter Estimates", "Across Covariates")

```

### Significant Coefficients?

An alternative lens on these figures highlights the statistical significance of the coefficients. But again, these criteria are much abused. Significance at what level? Conditional on which representation? Which composite outcome score? It should matter if thematically similar relationships are highlighted as we vary the input variables. This is a kind of check on the hypothesised dependency structure - on what cluster of variables does our model place the most weight?

```{r, fig.width=10, fig.height=7}


g1 = modelplot(mod_mean, coef_omit = 'Intercept') +  aes(color = ifelse(p.value < 0.001, "Significant at 0.001", "Not significant at 0.001")) +
  scale_color_manual(values = c("grey", "blue")) + ggtitle("Significance of Coefficient Values", "Mean Model at Different Levels")


g2 = modelplot(mod_mean, coef_omit = 'Intercept') +  aes(color = ifelse(p.value < 0.05, "Significant at 0.05", "Not significant at 0.05")) +
  scale_color_manual(values = c("grey", "black"))

plot <- ggarrange(g1,g2, ncol=2, nrow=1);



```

### Aggregate Driver Scores

Perhaps we play with the feature representation and increase the proportion of significant indicators. Can we now tell a more definitive story about how parental support and social self-efficact are determinants of self-reported life-satisfaction scores? Let's focus here on the sum score representation and add interaction effects.

```{r}

df$se_acad_mean <- rowMeans(df[c('se_acad_p1', 'se_acad_p2', 'se_acad_p3')])
df$se_social_mean <- rowMeans(df[c('se_social_p1', 'se_social_p2', 'se_social_p3')])
df$sup_friends_mean <- rowMeans(df[c('sup_friends_p1', 'sup_friends_p2', 'sup_friends_p3')])
df$sup_parents_mean <- rowMeans(df[c('sup_parents_p1', 'sup_parents_p2', 'sup_parents_p3')])


formula_parcel_sum = "ls_sum ~ se_acad_mean + se_social_mean +
sup_friends_mean + sup_parents_mean " #sup_parents_mean*se_social_mean"

formula_parcel_sum_inter = "ls_sum ~ se_acad_mean + se_social_mean + 
sup_friends_mean + sup_parents_mean + sup_parents_mean*se_social_mean"

mod_sum_parcel = lm(formula_parcel_sum, df)
mod_sum_inter_parcel = lm(formula_parcel_sum_inter, df)

models_parcel = list("model_sum_score" = mod_sum_parcel,
     "model_sum_inter_score"= mod_sum_inter_parcel
     )

modelsummary(models_parcel, stars=TRUE)

```

What does definitive mean here? Is it so simple as more significant coefficients? Marginally better performance measures?

```{r, fig.width = 14}

g1 = modelplot(mod_sum_parcel, coef_omit = 'Intercept') +  aes(color = ifelse(p.value < 0.05, "Significant at 0.05", "Not significant at 0.05")) +
  scale_color_manual(values = c("grey", "blue"), guide=FALSE) + ggtitle("Significance of Coefficient Values", "At Different Levels for Sum and Mean Scores Life Satisfaction ")


g2 = modelplot(mod_sum_inter_parcel, coef_omit = 'Intercept') +  aes(color = ifelse(p.value < 0.05, "Significant at 0.05", "Not significant at 0.05")) +
  scale_color_manual(values = c("grey", "blue"))

plot <- ggarrange(g1,g2, ncol=2, nrow=1);



```

This kind of brinkmanship is brittle. Any one of these kinds of choice **can** be justified but more often than not results from an suspect exploratory process. Steps down a ["garden of forking paths"](http://www.stat.columbia.edu/~gelman/research/unpublished/p_hacking.pdf) seeking some kind of story to justify an analysis or promote a conclusion. This post-hoc "seeking" is just bad science undermining the significance claims that accrue to reliable procedures. It warps the nature of testing procedure by corrupting the assumed consistency of repeatable trials. The guarantees of statistical significance attach to a conclusion just when the procedure is imagined replicible and repeated under identical conditions. By exploring the different representations and criteria of narrative adequacy we break those guarantees. The false precision of appeals to null hypothesis statistical hides this breadth of this discovery process while leveraging the rhetoric of theoretical guarantees that apply only in different possible world.

### Exploratory and Confirmatory Modes

One of the things that psychometrics has pioneered well is the distinction between an exploratory and confirmatory models. This distinction, when made explicit, partially guards against the abuse of inferential integrity we see in more common work-flows. We may fit a model to our data, we may tweak or adjust it in any way we care to - this is exploratory work, the point is that the model design is validated on unseen data. But additionally, models are often opaque - you may (as above) have improved some measure of model fit, changed the parameter weighting accorded to an observed feature, but what does that mean? Exploration of model architectures, design choices and feature creation is just how we come to understand the meaning of a model specification. Even in the simple case of regression we've seen how adding an interaction term changes the interpretability of a model. How then are we to stand behind uncertainty estimates accorded to parameter weights when we barely intuit the implications of a model design?

### Marginal Effects

The answer is to not to rely on intuition, but push forward and test the tangible implications of a fitted model. A model is hypothesis which should be applied to stringent test. We should subject the logical consequences of the design to appropriate scrutiny. We understand the implications and relative plausibility of any model in terms of the predicted outcomes more easily than we understand the subtle interaction effects expressed parameter movements. As such we should adopt this view in our evaluation of a model fit too.

Consider how we do this using Vincent Arel-Bundock's wonderful `marginaleffects` package passing a grid of new values through to our fitted model.These implications are a test of model plausibility too.

```{r, fig.width=10}
pred <- predictions(mod_sum_parcel, newdata = datagrid(sup_parents_mean = 1:10, se_social_mean = 1:10 ))
pred1 <- predictions(mod_sum_inter_parcel, newdata = datagrid(sup_parents_mean = 1:10, se_social_mean = 1:10))

pred1  |> tail(10) |> kableExtra::kable() |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")

```

We will see here how the impact of changes in `se_social_mean` is much reduced when `sup_parent_mean` is held fixed at high values (9, 10) when our model allows for an interaction effect.

```{r}

pred |> head(10) |> kableExtra::kable() |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")

```

This modifying effect is not as evident in the simpler model.

#### Regression Marginal Effects

We can see this more clearly with a plot of the marginal effects.

```{r, fig.width=10, fig.height=10}

g = plot_predictions(mod_sum_parcel, condition = c("se_social_mean", "sup_parents_mean"), type = "response") + ggtitle("Counterfactual Shift of Outcome: se_social_mean", "Holding all else Fixed: Simple Model")

g1 = plot_predictions(mod_sum_inter_parcel, condition = c("se_social_mean", "sup_parents_mean"), type = "response") + ggtitle("Counterfactual Shift of Outcome: se_social_mean", "Holding all else Fixed Interaction Model")

plot <- ggarrange(g,g1, ncol=1, nrow=2);


```

Here we've pulled out some of the implications in terms of the outcome predictions and see how the interaction effect modifies the additive effect downwards at the upper end of the `se_social_mean` scale. That is to say the y-axis recounts the aggregate `ls_sum` outcome variable and the x-axis varies values for `se_social_mean` while holding values the other covariates fixed at the mean level. The differences we see in the two plots are due to the extra effect of the modification the interaction term has on our prediction scale. The significance and practical impact of this interaction term should make us think harder about the manner in which social self-efficacy and parental support are related.

### Models with Controls

The garden of forking paths presents itself within any set of covariates. How do we represent their effects? Which interactions are meaningful? How do we argue for one model design over another? The questionable paths are multiplied when we begin to consider additional covariates and group effects. But also additional covariates help structure our expectations too. Yes, you can cut and chop your way to through the garden to find some spurious correlation but more plausibly you can bring in structurally important variables which helpfully moderate the outcomes based on our understanding of the data generating process.

Let's assess the question by allowing the model to account for differences in `region`. You might imagine other demographic features which contribute to varying life-satisfaction scores and it would be a further model refinement if we could collect the associated measures to augment our analysis. For now we focus on `region`.

```{r, fig.width=10}

formula_no_grp_sum = "ls_sum ~ sup_parents_p1 + sup_parents_p2 + sup_parents_p3 + sup_friends_p1 + sup_friends_p2 + sup_friends_p3 + se_acad_p1 + se_acad_p2 + se_acad_p3 +
se_social_p1 + se_social_p2 + se_social_p3"

formula_grp_sum = "ls_sum ~ sup_parents_p1 + sup_parents_p2 + sup_parents_p3 + sup_friends_p1 + sup_friends_p2 + sup_friends_p3 + se_acad_p1 + se_acad_p2 + se_acad_p3 +
se_social_p1 + se_social_p2 + se_social_p3 + factor(region)"

no_grp_sum_fit <- lm(formula_no_grp_sum , data = df)
grp_sum_fit <- lm(formula_grp_sum, data = df)

g1 = modelplot(no_grp_sum_fit, re.form=NA) +  aes(color = ifelse(p.value < 0.05, "Significant at 0.05", "Not significant at 0.001")) +
  scale_color_manual(values = c("grey", "blue"), guide='none') + ggtitle("Significance of Coefficient Values", "No Group Effects Model")

g2 = modelplot(grp_sum_fit, re.form=NA) +  aes(color = ifelse(p.value < 0.05, "Significant at 0.05", "Not significant 0.05")) +
  scale_color_manual(values = c("grey", "blue")) + ggtitle("Significance of Coefficient Values", "Group Effects Model")



plot <- ggarrange(g1,g2, ncol=2, nrow=1);


```

We can see here how the additional factor variable is reported to be significant conditional on a model specification. However the intercept is no longer well identified.

```{r}

modelsummary(list("No Group Effects Fit"= no_grp_sum_fit,
                  "Group Effects Fit"= grp_sum_fit), 
             stars = TRUE) |> 
 style_tt(
   i = 2:25,
   j = 1:1,
   background = "#17C2AD",
   color = "white",
   italic = TRUE)

```

Again the cleanest way to interpret the implications of these specifications is derive the conditional marginal effects and assess these for plausibility.

#### Group Marginal Effects

We see here the different levels expected for different regional responses for changes in each of these input variables.

```{r, fig.width=10, fig.height=10}

g = plot_predictions(grp_sum_fit, condition = c("sup_parents_p3", "region"), type = "response") + ggtitle("Counterfactual Shift of Outcome: sup_parents_p3", "Holding all else Fixed")

g1 = plot_predictions(grp_sum_fit, condition = c("sup_friends_p1", "region"), type = "response") + ggtitle("Counterfactual Shift of Outcome: sup_friends_p1", "Holding all else Fixed")

g2 = plot_predictions(grp_sum_fit, condition = c("se_acad_p1", "region"), 
                      type = "response") + ggtitle("Counterfactual Shift of Outcome: se_acad_p1", "Holding all else Fixed")

plot <- ggarrange(g,g1,g2, ncol=1, nrow=3);

```

In this case the differences are slight, but the point here is just to consider how aspects of the data generating process can be modified by broadly demographic features systematically. In an ideal circumstance a probability-sample of survey respondents should mitigate the need for additionally controls variables in so far as a probability sample should ensure exchangeability

## Interlude: Model Design and Conditional Exchangeability

Modelling is nearly always about contrasts and questions of meaningful differences. What we seek to do when we build a model is to find a structure that enables "fair" or "justified" inferences about these contrasts. This is maybe most palpably brought home when we consider cases of causal inference. Here we want to define a meaningful causal estimand - some contrast between treatment group and control group where we can be confident that the two groups are suitably "representative" so that the observed differences represents the effect of the treatment. We are saying that conditional on our model design we consider **the potential outcomes to be exchangable**. Or another way of putting it is that we have controlled for all aspects of systematic differences between the control and treatment group and this warrants the causal interpretation of the contrast between treatment and control.

But as we've seen above the cleanest way to interpret almost any regression model is to understand the model design in terms of the marginal effects on the outcome scale. These are just contrasts. All statistical models are, in some sense, focused on finding a structure that licenses an inference about some contrast of interest between the levels of some observed variable and the implied outcomes. In this way we want to include as much structure in our model that would induce the status of conditional exchangeability between the units of study across such group contrasts. This notion of conditional exchangeability is inherently an epistemic notion. We believe that our model is apt to induce the status of conditional exchangeability such that the people in our survey have no systematic difference which biases the measured differences. The implied differences in some marginal effect (while holding all else fixed) is a "fair" representations the same counterfactual adjustment in the population or sub-population defined by the covariate profile $X$. The model implied difference is a proxy for the result of possible future interventions and as such merits our attention in policy design.

In particular the view here is that we ought to be deliberate in how we structure our models to license the plausibility of the exchangeability claim. By De Finetti's theorem a distribution of exchangeable sequence of variables be expressed as mixture of conditional independent variables.

$$ p(x_{1}....x_{m}) = \dfrac{p(X | \theta)p(\theta)}{p_{i}(X)} $$

So if we specify the conditional distribution correctly, we recover the conditions that warrant inference with a well designed model.The mixture distribution is just the vector of parameters $\boldsymbol{\theta}$ upon which we condition our model. Mislevy and Levy highlight this important observation has implications for model development by quoting Judea Pearl:

> \[C\]onditional independence is not a grace of nature for which we must wait passively, but rather a psychological necessity which we satisfy by organising our knowledge in a specific way. An important tool in such an organisation is the identification of intermediate variables that induce conditional independence among observables; if such variables are not in our vocabulary, we create them. In medical diagnosis, for instance, when some symptoms directly influence one another, the medical profession invents a name for that interaction (e.g. "syndrome", "complication", "pathological state") and treats it as a new auxiliary variable that induces conditional independence." - Pearl quoted in *Bayesian Psychometric Modeling* p61

The organisation of our data into meaningful categories or clusters is common in machine learning, but similarly in psychometrics we see the prevalence of factor models which are more explicitly causal models where we posit some unifying theme to the cluster of measures. In each tradition we are seeking conditional independence by allowing the model to account for these dependencies in how we structure the model. These choices represent a fruitful aspect of walking down through the garden of forking paths. There is then a tension between the exploratory seeking for some pre-determined story and an experimental seeking of clarity. With this in mind we now turn to types of modeling architecture that open up new expressive possibilities and offer a way to think about the relationships between observed data and latent factors that drive the observed outcomes. This greater expressive power offers different routes to inducing patterns of conditional exchangeability and different risks too.

## Expressive Structure: Building the Model we Need

In some sense the modeling we've seen so far is simply inadequate to express our theory of the case. The hypothetical structure with which we started abstracted over the measures in our data. The theory talks of LIFE SATISFACTION and PARENTAL SUPPORT as grand holistic constructs, yet in our regression model(s) we have loosely coupled our measurements and the intended target via indirect but hopefully indicative measures. We can do better if we're more explicit about how these manifest metrics ladder up to our latent constructs.

### Confirmatory Factor Analysis

We will illustrate the details of confirmatory factor modelling using the `lavaan` framework. The focus is mostly on the mechanics of how these models are estimated using maximum likelihood techniques before illustrating the salient differences of Bayesian estimation.

First recall that the idea of confirmatory factor analysis is that there are some latent constructs which determine our data generating process. In our survey we've already clustered our questions by themes so it makes sense to extend this idea to posit latent constructs mapped to each of these themes. In the jargon of structural equation models this is called the measurement model.

```{r fig.width=10, fig.height=10}

model_measurement <- "
# Measurement model
SUP_Parents =~ sup_parents_p1 + sup_parents_p2 + sup_parents_p3
SUP_Friends =~ sup_friends_p1 + sup_friends_p2 + sup_friends_p3
SE_Academic =~ se_acad_p1 + se_acad_p2 + se_acad_p3
SE_Social =~ se_social_p1 + se_social_p2 + se_social_p3
LS  =~ ls_p1 + ls_p2 + ls_p3
"

model_measurement1 <- "
# Measurement model
SUP_Parents =~ b1*sup_parents_p1 + b2*sup_parents_p2 + b3*sup_parents_p3
SUP_Friends =~ a1*sup_friends_p1 + a2*sup_friends_p2 + a3*sup_friends_p3
SE_Academic =~ c1*se_acad_p1 + c2*se_acad_p2 + c3*se_acad_p3
SE_Social =~ se_social_p1 + se_social_p2 + se_social_p3
LS  =~ ls_p1 + ls_p2 + ls_p3

a1 == a2 
a1 == a3
b1 == b2
b1 == b3
c1 == c2
c1 == c3

"

fit_mod <- cfa(model_measurement, data = df)
fit_mod_1<- cfa(model_measurement1, data = df)

```

In the above syntax we have specified two slightly different measurement models. In each case we allow that the questions of our survey are mapped to an appropriate latent factor e.g `LS =~ ls_p1 + ls_p2 + ls_p3`. The "=\~" syntax denotes a "measured by" relationship in which the goal is to estimate how each of observed measurements load on the latent factor. In the first model we have allowed each of the factor loadings to be estimated freely, but in the second we have forced equal weights on the `SUP_Friends` construct. A benefit of this framework is that we do not have to resort to crude aggregations like sum-scores or mean-scores over the outcome variables we can allow that they vary freely and let the model estimate the multivariate relationships between the observed variables and these latent constructs.

If we plot the estimated parameters as before we'll see some additional parameters reported.

```{r}


cfa_models = list("full_measurement_model" = fit_mod, 
     "measurement_model_reduced" = fit_mod_1)
modelplot(cfa_models)

```

Here there are two distinct types of parameters: (i) the factor loadings accorded (=\~) to the individual observed metrics and (ii) the covariances (\~\~) between the latent constructs. We can further report the extent of the model fit summaries.

```{r, fig.width=10, fig.height=10}

summary(fit_mod, fit.measures = TRUE, standardized = TRUE) 

```

Note how in addition to the individual parameter estimates the summaries highlight various measures of global model fit. These model fit statistics are important for evaluating alternative ways of parameterising our models. The number of parameters is a real concern in the maximum likelihood approaches to estimating these models. Too many parameters and we can easily over fit to the particular sample data. This stems in part from the limitations of the optimization goal in the traditional CFA framework - we are intent to optimize model parameters to recover a compelling estimate based on the observed covariance matrix. Once we have more parameters than there are points in the covariance matrix the model is free to overfit considerably. This can then be checked as measure of local model fit and may highlight infelicities or suspicious convergence between the true data generating process and the learned model.

```{r, fig.width=10, fig.height=12}

g1 = plot_heatmap(cov(df[,  drivers]))

g2 = plot_heatmap(data.frame(fitted(fit_mod)$cov)[drivers, drivers], title="Model Implied Covariances", "Fitted Values")

resids = cov(df[,  drivers]) - data.frame(fitted(fit_mod)$cov)[drivers, drivers]

g3 = plot_heatmap(resids, title="Residuals", "Fitted Values versus Observe Sample Covariance")


plot <- ggarrange(g1,g2,g3, ncol=1, nrow=3);
```

#### Summary Global Fit Measures

We can also compare models based on their global measures of model fit giving some indication of whether parameter specifications improve or reduce fidelity with the true data generating process.

```{r}

summary_df = cbind(fitMeasures(fit_mod, c("chisq", "baseline.chisq", "cfi", "aic", "bic", "rmsea","srmr")),
      fitMeasures(fit_mod_1, c("chisq", "baseline.chisq", "cfi", "aic", "bic", "rmsea","srmr")))
colnames(summary_df) = c('Full Model', 'Reduced Model')

summary_df |> kable() |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")

```

There a wealth of metrics associated with CFA model fit and it can be hard to see the forest for the trees.

#### Visualizing the Relationships

One of the better ways to visualize these models is to use the `semPlot` package. Here we can plot all the parameter estimates in one graph. Following convention the rectangular boxes represent observed measures. Oval or circular objects represent the latent constructs. The self-directed arrows on each node is the variance of that measure. The two-way arrows between nodes represents the covariance between those two nodes. The single headed arrows from the latent construct to the indicator variables denotes the factor loading of the variable on the construct. For instance `SUP_F -> sp_f_3` is set at 0.89.

```{r}

semPlot::semPaths(fit_mod, whatLabels = 'est', intercepts = FALSE)

```

For instance, in this plot you can see that for each latent construct one of the indicator variables has their factor loading set to 1. This is a mathematical requirement we'll see below that is used to ensure identifiability of the parameters akin to setting a reference category in categorical regression. In the plot you can "read-off" the covariances between our constructs e.g. the covariance between `LS` and `SUP_P` is 0.36 the largest value amongst the set of covariances.

#### Comparing Models

We can use a variety of chi-squared tests to evaluate the goodness of fit for our models. If we pass in each model individually we perform a test comparing our model to the saturated model. The Chi-Squared test compares the model-implied variance-covariance matrix (expected) to the variance-covariance matrix computed from the actual data (observed). The null hypothesis for the Chi-Squared Goodness-of-Fit test is that the model fits the data perfectly, meaning that there is no significant difference between the observed and model-implied variance-covariance matrices. The goal is to see if the differences between these matrices are large enough that we can reject the null.

```{r}

lavTestLRT(fit_mod)

```

Passing in the one model we can reject the null hypothesis that the saturated model's (perfect fit) and the candidate variance-covariance matrix are drawn from the same distribution. Comparing between our two model fits we also reject that these two models are drawn from the same distribution.

```{r}

lavTestLRT(fit_mod, fit_mod_1)


```

The test also reports a number of other fit indices and the degrees of freedom available to each model. These are important because the Chi-Squared test is overly sensitive in large-sample data and the model adequacy is a multi-dimensional question.

### Structural Equation Models

So far so good. We have a confirmatory factor measurement model. We've structured it so that we can make inferences about the correlations and covariances between 5 latent constructs of independent interest. We've calibrated the model fit statistics by ensuring the model can reasonably recover the observed variance-covariance structure. But what about our dependency relations between constructs? We can evaluate these too! Adding regressions to our model allows to express these relationships and then recover summary statistics of the same.

```{r}

model <- "
# Measurement model
SUP_Parents =~ sup_parents_p1 + sup_parents_p2 + sup_parents_p3
SUP_Friends =~ sup_friends_p1 + sup_friends_p2 + sup_friends_p3
SE_Academic =~ se_acad_p1 + se_acad_p2 + se_acad_p3
SE_Social =~ se_social_p1 + se_social_p2 + se_social_p3
LS  =~ ls_p1 + ls_p2 + ls_p3

# Structural model 
# Regressions
SE_Academic ~ SUP_Parents + SUP_Friends
SE_Social ~ SUP_Parents + SUP_Friends
LS ~ SE_Academic + SE_Social + SUP_Parents + SUP_Friends

# Residual covariances
SE_Academic ~~ SE_Social
"

fit_mod_sem <- sem(model, data = df)
```

This model structure adds a set of directional arrows between the latent constructs

```{r}

semPlot::semPaths(fit_mod_sem, whatLabels = 'est', intercepts = FALSE)

```

The relative uncertainty in each estimates

```{r}
modelplot(fit_mod_sem)

```

Compare this structure against the previous and simpler measurement model and we observe a puzzling phenomena. The models report identical measures of fit! Despite the extra structure in the SEM model the optimization routine has returned identical parameter specifications.

```{r}

summary_df = cbind(fitMeasures(fit_mod, c("chisq", "baseline.chisq", "cfi", "aic", "bic", "rmsea","srmr")),
      fitMeasures(fit_mod_sem, c("chisq", "baseline.chisq", "cfi", "aic", "bic", "rmsea","srmr")),
      fitMeasures(fit_mod_1, c("chisq", "baseline.chisq", "cfi", "aic", "bic", "rmsea","srmr")))
colnames(summary_df) = c('Full Model', 'SEM Model', 'Reduced Model')

summary_df |> kable() |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")


```

The issue here is that the models have the same degrees of freedom which suggests in some sense we have already saturated our model fit and are unable to evaluate further parameter estimates.

```{r}

lavTestLRT(fit_mod_sem, fit_mod)

lavTestLRT(fit_mod_sem, fit_mod_1)

```

We can see this similarly in the plotted residuals which are identical across the models despite meaningful structural differences.

```{r fig.width=10, fig.height=8}

heat_df = data.frame(resid(fit_mod)$cov) 
heat_df = heat_df |> as.matrix() |> melt()
colnames(heat_df) <- c("x", "y", "value")

g1 = heat_df  |> mutate(value = round(value, 2)) |>  ggplot(aes(x = x, y = y, fill = value)) +
  geom_tile() + geom_text(aes(label = value), color = "black", size = 4) +
 scale_fill_gradient2(
    high = 'dodgerblue4',
    mid = 'white',
    low = 'firebrick2'
  ) + theme(axis.text.x = element_text(angle=45)) + ggtitle("Residuals of the Sample Covariances and Model Implied Covariances", "A Visual Check of Structural-Model fit")


heat_df = data.frame(resid(fit_mod_sem)$cov) 
heat_df = heat_df |> as.matrix() |> melt()
colnames(heat_df) <- c("x", "y", "value")

g2 = heat_df  |> mutate(value = round(value, 2)) |>  ggplot(aes(x = x, y = y, fill = value)) +
  geom_tile() + geom_text(aes(label = value), color = "black", size = 4) +
 scale_fill_gradient2(
    high = 'dodgerblue4',
    mid = 'white',
    low = 'firebrick2'
  ) + theme(axis.text.x = element_text(angle=45)) + ggtitle("Residuals of the Sample Covariances and Model Implied Covariances", "A Visual Check of Measurement-Model fit")


plot <- ggarrange(g1,g2, ncol=1, nrow=2);

```

This is a genuine limitation in the expressive power of SEM models when they are fit using maximum likelihood while optimizing for fidelity to the sample variance-covariance matrix. Model idenfification possibilities are constrained by the optimisation goal and the degrees of freedom available to the optimiser. This constrains the model structures we can evaluate. Next we'll show how the Bayesian approach to estimating these models frees us from this limitation.

### Confirmatory Factor Models with `PyMC`

So far we've seen CFA and SEM models specified using a kind of formula syntax. This useful but here we switch to the distributional perspective which is more directly relevant to the Bayesian phrasing of the CFA model. We'll unpack these components of the distributional view with a simpler data set initially for illustrative purposes and then we'll switch back to the Life Satisfaction question.

```{python}

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pytensor import tensor as pt
import arviz as az
import networkx as nx
np.random.seed(150)



df_p = pd.read_csv('IIS.dat', sep='\s+')
df_p.head()

```

We have here a dataset drawn from Mislevy and Levy. which records measures of students collegiate experiences along multiple dimensions. The data here represents the averages of `PI` peer interaction, `AD` academic development `IGC` goal commitment, `FI` faculty interaction and `FC` faculty concern items for 500 hundred students. We will fit a 2 factor Bayesian CFA model to this data set - one factor for he faculty items and the other factor for self-reporting items. First consider the code and then we'll step through it in more detail.

```{python results='hide'}

coords = {'obs': list(range(len(df_p))), 
          'indicators': ['PI', 'AD',	'IGC', 'FI', 'FC'],
          'indicators_1': ['PI', 'AD',	'IGC'],
          'indicators_2': ['FI', 'FC'],
          'latent': ['Student', 'Faculty']
          }


obs_idx = list(range(len(df_p)))
with pm.Model(coords=coords) as model:
  
  Psi = pm.InverseGamma('Psi', 5, 10, dims='indicators')
  lambdas_ = pm.Normal('lambdas_1', 1, 10, dims=('indicators_1'))
  # Force a fixed scale on the factor loadings for factor 1
  lambdas_1 = pm.Deterministic('lambdas1', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_1'))
  lambdas_ = pm.Normal('lambdas_2', 1, 10, dims=('indicators_2'))
  # Force a fixed scale on the factor loadings for factor 2
  lambdas_2 = pm.Deterministic('lambdas2', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_2'))
  tau = pm.Normal('tau', 3, 10, dims='indicators')
  # Specify covariance structure between latent factors
  kappa = 0
  sd_dist = pm.Exponential.dist(1.0, shape=2)
  chol, _, _ = pm.LKJCholeskyCov('chol_cov', n=2, eta=2,
    sd_dist=sd_dist, compute_corr=True)
  ksi = pm.MvNormal('ksi', kappa, chol=chol, dims=('obs', 'latent'))

  # Construct Observation matrix
  m1 = tau[0] + ksi[obs_idx, 0]*lambdas_1[0]
  m2 = tau[1] + ksi[obs_idx, 0]*lambdas_1[1]
  m3 = tau[2] + ksi[obs_idx, 0]*lambdas_1[2]
  m4 = tau[3] + ksi[obs_idx, 1]*lambdas_2[0]
  m5 = tau[4] + ksi[obs_idx, 1]*lambdas_2[1]
  
  mu = pm.Deterministic('mu', pm.math.stack([m1, m2, m3, m4, m5]).T)
  _  = pm.Normal('likelihood', mu, Psi, observed=df_p.values)

  idata = pm.sample(nuts_sampler='numpyro', target_accept=.95, 
                    idata_kwargs={"log_likelihood": True})
  idata.extend(pm.sample_posterior_predictive(idata))
  
summary_df = az.summary(idata, var_names=['lambdas1', 'lambdas2', 'tau', 'Psi', 'ksi', 'chol_cov_corr'], coords= {'obs': [0, 7]})

```

The model specification here has a Normal likelihood term which takes as observed data the matrix of student responses. However we construct the input for the likelihood term in a way that we posit two latent factor variables `ksi[obs_idx, 0]` and `ksi[obs_idx, 1]` respectively. These factors are modified by the factor loading terms in e.g. `lambdas_1` specification to create a regression model `m1` which predicts the indicator variable `PI`. In this way we allow that the latent factors are related to the observed data matrix and the manner in which calibrating against observed data modifies our priors for the parameterisations of the lambdas, ksi terms reflects what the model learns about the interactions between the latent constructs. Crucially we force a covariance structure on `ksi` terms to reflect the correlations and covariance between these constructs of interest and the factor loading terms have a required scale fixed by forcing the first indicator loading to 1 for each factor.

In a Bayesian approach to the estimation of these models we are not limited by the degrees of freedom available in the optimisation routine. Instead we're aiming to estimate the posterior distribution using MCMC on draws from well specified priors on each the quantities listed above. In a picture the structure is like this:

![PyMC Confirmatory Factor Model](pymc_model.png)

We are conditioning on the observed data and seek to estimate sound parameterisations of the `ksi`, `lambda` and `tau` that go into building our mu structure. The marginal distribution of the observables is derived by integrating over the distribution of the latent variables in this fashion so that:

$$ p(x_{i}.....x_{n} | ksi, \Psi, \tau, \Lambda) \sim Normal(\tau + \Lambda\cdot ksi, \Psi) $$ For more details on the precise derivation of this likelihood term we recommend the discussion in the book. It is this same likelihood specification that is used in maximum likelihood fits of the same and the Normal assumption has proved viable and computationally tractable. The model yields summary statistics for each of these parameters.

```{r}

py$summary_df |> kable() |>  kable_classic(full_width = F, html_font = "Cambria")

```

We can additionally check the diagnostic trace plots to ensure that the model has sampled well even across the relatively complex structure.

```{python}

az.plot_trace(idata, var_names=['lambdas1', 'lambdas2', 'tau', 'Psi', 'ksi']);

```

These diagnostic plots and parameter estimates reflect well the same figures reported by Levy and Mislevy, so we won't dwell too much further on this model only to say that the basic structure here is expanded upon as we apply more factor structures and SEM like structures to our original Life-Satisfaction dataset.

#### Factoring for Life Satisfaction

Now we want fit the life-satisfaction measurement model using `PyMC`. This has fundamentally a similar structure to the simple CFA model we've seen above. However we now have 5 factors with 3 factor loadings to be estimated for three indicators per factor. We will fit this model and then show how to pull out some of model fit statistics that are relevant for the assessment of the model.

```{python results='hide'}

df = pd.read_csv('sem_data.csv')
drivers = ['se_acad_p1', 'se_acad_p2',
       'se_acad_p3', 'se_social_p1', 'se_social_p2', 'se_social_p3',
       'sup_friends_p1', 'sup_friends_p2', 'sup_friends_p3', 'sup_parents_p1',
       'sup_parents_p2', 'sup_parents_p3', 'ls_p1', 'ls_p2', 'ls_p3']
       
```

```{python results='hide'}
coords = {'obs': list(range(len(df))), 
          'indicators': drivers,
          'indicators_1': ['se_acad_p1','se_acad_p2','se_acad_p3'],
          'indicators_2': ['se_social_p1','se_social_p2','se_social_p3'],
          'indicators_3': ['sup_friends_p1','sup_friends_p2','sup_friends_p3'],
          'indicators_4': [ 'sup_parents_p1','sup_parents_p2','sup_parents_p3'],
          'indicators_5': ['ls_p1','ls_p2', 'ls_p3'],
          'latent': ['SE_ACAD', 'SE_SOCIAL', 'SUP_F', 'SUP_P', 'LS'],
          'latent1': ['SE_ACAD', 'SE_SOCIAL', 'SUP_F', 'SUP_P', 'LS']
          }

obs_idx = list(range(len(df)))
with pm.Model(coords=coords) as model:
  
  Psi = pm.InverseGamma('Psi', 5, 10, dims='indicators')
  lambdas_ = pm.Normal('lambdas_1', 1, 10, dims=('indicators_1'))
  lambdas_1 = pm.Deterministic('lambdas1', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_1'))
  lambdas_ = pm.Normal('lambdas_2', 1, 10, dims=('indicators_2'))
  lambdas_2 = pm.Deterministic('lambdas2', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_2'))
  lambdas_ = pm.Normal('lambdas_3', 1, 10, dims=('indicators_3'))
  lambdas_3 = pm.Deterministic('lambdas3', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_3'))
  lambdas_ = pm.Normal('lambdas_4', 1, 10, dims=('indicators_4'))
  lambdas_4 = pm.Deterministic('lambdas4', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_4'))
  lambdas_ = pm.Normal('lambdas_5', 1, 10, dims=('indicators_5'))
  lambdas_5 = pm.Deterministic('lambdas5', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_5'))
  tau = pm.Normal('tau', 3, 10, dims='indicators')
  kappa = 0
  sd_dist = pm.Exponential.dist(1.0, shape=5)
  chol, _, _ = pm.LKJCholeskyCov('chol_cov', n=5, eta=2,
    sd_dist=sd_dist, compute_corr=True)
  cov = pm.Deterministic("cov", chol.dot(chol.T), dims=('latent', 'latent1'))
  ksi = pm.MvNormal('ksi', kappa, chol=chol, dims=('obs', 'latent'))

  m0 = tau[0] + ksi[obs_idx, 0]*lambdas_1[0]
  m1 = tau[1] + ksi[obs_idx, 0]*lambdas_1[1]
  m2 = tau[2] + ksi[obs_idx, 0]*lambdas_1[2]
  m3 = tau[3] + ksi[obs_idx, 1]*lambdas_2[0]
  m4 = tau[4] + ksi[obs_idx, 1]*lambdas_2[1]
  m5 = tau[5] + ksi[obs_idx, 1]*lambdas_2[2]
  m6 = tau[6] + ksi[obs_idx, 2]*lambdas_3[0]
  m7 = tau[7] + ksi[obs_idx, 2]*lambdas_3[1]
  m8 = tau[8] + ksi[obs_idx, 2]*lambdas_3[2]
  m9 = tau[9] + ksi[obs_idx, 3]*lambdas_4[0]
  m10 = tau[10] + ksi[obs_idx, 3]*lambdas_4[1]
  m11 = tau[11] + ksi[obs_idx, 3]*lambdas_4[2]
  m12 = tau[12] + ksi[obs_idx, 4]*lambdas_5[0]
  m13 = tau[13] + ksi[obs_idx, 4]*lambdas_5[1]
  m14 = tau[14] + ksi[obs_idx, 4]*lambdas_5[2]
  
  mu = pm.Deterministic('mu', pm.math.stack([m0, m1, m2, m3, m4, m5, m6, m7,
                                             m8, m9, m10, m11, m12, m13, m14]).T)
  _  = pm.Normal('likelihood', mu, Psi, observed=df[drivers].values)

  idata = pm.sample(nuts_sampler='numpyro', target_accept=.95, tune=1000,
                    idata_kwargs={"log_likelihood": True}, random_seed=100)
  idata.extend(pm.sample_posterior_predictive(idata))
  
summary_df1 = az.summary(idata, var_names=['lambdas1', 'lambdas2', 'lambdas3', 'lambdas4', 'lambdas5', 'tau', 'Psi'])

cov_df = pd.DataFrame(az.extract(idata['posterior'])['cov'].mean(axis=2))
cov_df.index = ['SE_ACAD', 'SE_SOCIAL', 'SUP_F', 'SUP_P', 'LS']
cov_df.columns = ['SE_ACAD', 'SE_SOCIAL', 'SUP_F', 'SUP_P', 'LS']

correlation_df = pd.DataFrame(az.extract(idata['posterior'])['chol_cov_corr'].mean(axis=2))
correlation_df.index = ['SE_ACAD', 'SE_SOCIAL', 'SUP_F', 'SUP_P', 'LS']
correlation_df.columns = ['SE_ACAD', 'SE_SOCIAL', 'SUP_F', 'SUP_P', 'LS']

factor_loadings = pd.DataFrame(az.summary(idata, var_names=['lambdas1', 'lambdas2', 'lambdas3', 'lambdas4', 'lambdas5'])['mean']).reset_index()
factor_loadings['factor'] = factor_loadings['index'].str.split('[', expand=True)[0]
factor_loadings.columns =['factor_loading', 'factor_loading_weight', 'factor']
factor_loadings['factor_loading_weight_sq'] = factor_loadings['factor_loading_weight']**2
factor_loadings['sum_sq_loadings'] = factor_loadings.groupby('factor')['factor_loading_weight_sq'].transform(sum)


```

Here we've calculated a bunch of summary statistics which we will highlight below, but first observe the analogous model structure here to the simple CFA model above.

![Life Satisfaction Model](full_pymc_model.svg) Next we'll plot the posterior summary statistics for each of the key parameters.

```{r}

py$summary_df1 |> kable() |>  kable_classic(full_width = F, html_font = "Cambria")

```

Using a forest plots it's easier to see how the uncertainty attaches to some of these estimates.

```{python}

fig, ax = plt.subplots(figsize=(15, 8))
az.plot_forest(idata, var_names=['lambdas1', 'lambdas2', 'lambdas3', 'lambdas4', 'lambdas5'], combined=True, ax=ax);
ax.set_title("Factor Loadings for each of the Five Factors");

```

We can also pull out the covariances between our latent constructs. Highlighting the key covariances relations between support and self-efficacy measures with the life-satisfaction outcome.

```{r}

py$cov_df |> kable(caption= "Covariances Amongst Latent Factors",digits=2) |> kable_styling() %>% kable_classic(full_width = F, html_font = "Cambria") |> row_spec(5, color = "red")

```

One benefit of fitting a mutlivariate normal relationship between these factors is that we can pull and translate the covariance relation in terms of the correlation patterns implied.

```{r}

py$correlation_df |> kable( caption= "Correlations Amongst Latent Factors", digits=2) |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria") |> row_spec(5, color = "red")


```

Another lens on the factors is the relative factor strength which highlights where the majority of substantive variation exists in our data-set.

```{r}

py$factor_loadings[ c('factor', 'factor_loading', 'factor_loading_weight', 'factor_loading_weight_sq', 'sum_sq_loadings')] |> kable( caption= "Factor Loadings and Sum of Squared loadings", digits=2) |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria") |> column_spec(5, bold=TRUE, color = ifelse(py$factor_loadings$sum_sq_loadings > 2.8, "red", "black"))


```

So we can evaluate some of the similar relationships at the level of summary statistics, but more powerfully we've built a generative model of the process yielding our observed data and as such we can evalute the fidelity of the predictive output of our model using posterior predictive checks.

```{python, fig.width=10, fig.height=15}

def make_ppc(idata, samples=100):
  fig, axs = plt.subplots(5, 3, figsize=(20, 20))
  axs = axs.flatten()
  for i in range(15):
    for j in range(samples):
      temp = az.extract(idata['posterior_predictive'].sel({'likelihood_dim_3': i}))['likelihood'].values[:, j]
      temp = pd.DataFrame(temp, columns=['likelihood'])
      if j == 0:
        axs[i].hist(df[drivers[i]], alpha=0.3, ec='black', bins=20, label='Observed Scores')
        axs[i].hist(temp['likelihood'], color='purple', alpha=0.1, bins=20, label='Predicted Scores')
      else: 
        axs[i].hist(df[drivers[i]], alpha=0.3, ec='black', bins=20)
        axs[i].hist(temp['likelihood'], color='purple', alpha=0.1, bins=20)
      axs[i].set_title(f"Posterior Predictive Checks {drivers[i]}")
      axs[i].legend();
  plt.show()
  
make_ppc(idata)

```

In this way we can see how plausibly our model can capture the patterns in the observed data at the level of individual predictions. But additionally we can assess the posterior predictive fit at the level of summary statistics by defining the residuals on the model-fit covariance matrix based on draws from the posterior distribution.

```{python}

def get_posterior_resids(idata, samples=100, metric='cov'):
  resids = []
  for i in range(100):
    if metric == 'cov':
      model_cov = pd.DataFrame(az.extract(idata['posterior_predictive'])['likelihood'][:, :, i]).cov()
      obs_cov = df[drivers].cov()
    else: 
      model_cov = pd.DataFrame(az.extract(idata['posterior_predictive'])['likelihood'][:, :, i]).corr()
      obs_cov = df[drivers].corr()
    model_cov.index = obs_cov.index
    model_cov.columns = obs_cov.columns
    residuals = model_cov - obs_cov
    resids.append(residuals.values.flatten())
  
  residuals_posterior = pd.DataFrame(pd.DataFrame(resids).mean().values.reshape(15, 15))
  residuals_posterior.index = obs_cov.index
  residuals_posterior.columns = obs_cov.index
  return residuals_posterior

residuals_posterior_cov = get_posterior_resids(idata, 500)
residuals_posterior_corr = get_posterior_resids(idata, 500, metric='corr')

  
```

Then we can plot the familiar heat-maps from above highlighting the comparable accuracy of the Bayesian model fit.

```{r fig.width=10}

plot_heatmap(py$residuals_posterior_cov, "Residuals of the Sample Covariances and Model Implied Covariances", "A Visual Check of Bayesian Measurement Model fit")

plot_heatmap(py$residuals_posterior_corr, "Residuals of the Sample Correlations and Model Implied Correlations", "A Visual Check of Bayesian Measurement Model fit")

```

This process highlights one major difference in how the Bayesian CFA model is free to fit to the observed data. The parameterisation of the model is calibrated through the likelihood mechanism but the posterior samples provide important information not recoverable by optimizing fits for measurement and structural parameters in the MLE setting. In the Bayesian setting we have access to the latent factor scores for each of the individual responses, giving us a means of assessing outliers on the latent scales. For instance

```{python, fig.width=10}
fig, axs = plt.subplots(1, 2, figsize=(10, 10))
axs = axs.flatten()
ax = axs[0]
ax1 = axs[1]
az.plot_forest(idata, var_names=['ksi'], combined=True, ax=ax, coords={'latent': ['SUP_P']});
az.plot_forest(idata, var_names=['ksi'], combined=True, ax=ax1, colors="slateblue", coords={'latent': ['LS']});
ax.set_yticklabels([]);
ax.set_xlabel("SUP_P");
ax1.set_yticklabels([]);
ax1.set_xlabel("LS");
ax.axvline(-2, color='red');
ax1.axvline(-2, color='red');
ax.set_title("Individual Parental Support Metric \n On Latent Factor SUP_P");
ax1.set_title("Individual Life Satisfaction Metric \n On Latent Factor LS");
plt.show();

```

So while we are fitting a **confirmatory factor model** the edges between exploratory and confirmatory blur in this setting. Just because we have we a hypothesized factor structure we wish to evaluate does not mean the implications of such structures are crystal clear. Here we need to explore that the individually reported scores render plausible judgments about the relative position of each survey respondent on these latent scales. These are the implications of our model fit that would help us confirm the plausibility of the hypothesized factors, but additionally they offer new potential options for exploring our data and categorizing our observations. This is a common experience in contemporary Bayesian model workflow which recommends iterative model refinement and evaluation.

> "A key part of Bayesian workflow is adapting the model to the data at hand and the questions of interest. The model does not exist in isolation and is not specified from the outside; it emerges from engagement with the application and the available data" - Gelman et al in [Bayesian Workflow](https://arxiv.org/pdf/2011.01808)

This is the lens that matters. Yes, iterative refinement and model checking can lead to models which are over-fit to the sample data. This is always a risk, but explicit modeling workflow highlights prior designs and exposes this sequence of model choices to stringent tests. The choices that the determine trajectory of our refinements should represent a process of learning and discovery that uncovers more questions of interest as we expand the capacity of our models.

### Structural Equation Modelling in `PyMC`

In the context of structural equation modeling our hypothetical factor structure and dependency relations are even more specific than the simple "measurement model" we've just seen. A structural equation model incorporates a measurement model (a sub-component) and adds regression components between the latent and manifest variables as is required to evaluate candidate hypotheses regarding the structure of the data generating process. The range of possibilities we can encode here is vast, but candidate model architectures are constrained by our theory of the case and the demands of explanatory coherence.

#### SEM and Indirect Effects

With the life-satisfaction data-set we've been been looking at we want to evaluate the indirect and direct effects of parental and peer support on life-satisfaction outcomes. To do so we need to add a dependency structure to our data generating process and fit the regressions which would inform us as to relative importance of these types of support as mediated through our self-efficacy scores.

```{python results='hide'}


def make_indirect_sem(priors): 

  coords = {'obs': list(range(len(df))), 
            'indicators': drivers,
            'indicators_1': ['se_acad_p1','se_acad_p2','se_acad_p3'],
            'indicators_2': ['se_social_p1','se_social_p2','se_social_p3'],
            'indicators_3': ['sup_friends_p1','sup_friends_p2','sup_friends_p3'],
            'indicators_4': [ 'sup_parents_p1','sup_parents_p2','sup_parents_p3'],
            'indicators_5': ['ls_p1','ls_p2', 'ls_p3'],
            'latent': ['SUP_F', 'SUP_P'], 
            'latent1': ['SUP_F', 'SUP_P'], 
            'latent_regression': ['SUP_F->SE_ACAD', 'SUP_P->SE_ACAD', 'SUP_F->SE_SOC', 'SUP_P->SE_SOC'],
            'regression': ['SE_ACAD', 'SE_SOCIAL', 'SUP_F', 'SUP_P']
            }

  obs_idx = list(range(len(df)))
  with pm.Model(coords=coords) as model:
    
    Psi = pm.InverseGamma('Psi', 5, 10, dims='indicators')
    lambdas_ = pm.Normal('lambdas_1',  priors['lambda'][0], priors['lambda'][1], dims=('indicators_1'))
    lambdas_1 = pm.Deterministic('lambdas1', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_1'))
    lambdas_ = pm.Normal('lambdas_2', priors['lambda'][0], priors['lambda'][1], dims=('indicators_2'))
    lambdas_2 = pm.Deterministic('lambdas2', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_2'))
    lambdas_ = pm.Normal('lambdas_3', priors['lambda'][0], priors['lambda'][1], dims=('indicators_3'))
    lambdas_3 = pm.Deterministic('lambdas3', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_3'))
    lambdas_ = pm.Normal('lambdas_4', priors['lambda'][0], priors['lambda'][1], dims=('indicators_4'))
    lambdas_4 = pm.Deterministic('lambdas4', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_4'))
    lambdas_ = pm.Normal('lambdas_5', priors['lambda'][0], priors['lambda'][1], dims=('indicators_5'))
    lambdas_5 = pm.Deterministic('lambdas5', pt.set_subtensor(lambdas_[0], 1), dims=('indicators_5'))
    tau = pm.Normal('tau', 3, 10, dims='indicators')
    kappa = 0
    sd_dist = pm.Exponential.dist(1.0, shape=2)
    chol, _, _ = pm.LKJCholeskyCov('chol_cov', n=2, eta=priors['eta'],
      sd_dist=sd_dist, compute_corr=True)
    cov = pm.Deterministic("cov", chol.dot(chol.T), dims=('latent', 'latent1'))
    ksi = pm.MvNormal('ksi', kappa, chol=chol, dims=('obs', 'latent'))

    # Regression Components
    beta_r = pm.Normal('beta_r', 0, 0.5, dims='latent_regression')
    beta_r2 = pm.Normal('beta_r2', 0, 1, dims='regression')
    resid_chol, _, _ = pm.LKJCholeskyCov('resid_chol', n=2, eta=priors['eta'],
      sd_dist=sd_dist, compute_corr=True)
    _ = pm.Deterministic("resid_cov", chol.dot(chol.T))
    sigmas_resid = pm.MvNormal('sigmas_resid', kappa, chol=resid_chol)



    # SE_ACAD ~ SUP_FRIENDS + SUP_PARENTS 
    regression_se_acad = pm.Normal('regr_se_acad', beta_r[0]*ksi[obs_idx, 0] + beta_r[1]*ksi[obs_idx, 1], sigmas_resid[0])
    # SE_SOCIAL ~ SUP_FRIENDS + SUP_PARENTS 
    
    regression_se_social = pm.Normal('regr_se_social', beta_r[2]*ksi[obs_idx, 0] + beta_r[3]*ksi[obs_idx, 1], sigmas_resid[1])

    # LS ~ SE_ACAD + SE_SOCIAL + SUP_FRIEND + SUP_PARENTS
    regression = pm.Normal('regr', beta_r2[0]*regression_se_acad + beta_r2[1]*regression_se_social +
                                   beta_r2[2]*ksi[obs_idx, 0] + beta_r2[3]*ksi[obs_idx, 1], 1)

    m0 = tau[0] + regression_se_acad*lambdas_1[0]
    m1 = tau[1] + regression_se_acad*lambdas_1[1]
    m2 = tau[2] + regression_se_acad*lambdas_1[2]
    m3 = tau[3] + regression_se_social*lambdas_2[0]
    m4 = tau[4] + regression_se_social*lambdas_2[1]
    m5 = tau[5] + regression_se_social*lambdas_2[2]
    m6 = tau[6] + ksi[obs_idx, 0]*lambdas_3[0]
    m7 = tau[7] + ksi[obs_idx, 0]*lambdas_3[1]
    m8 = tau[8] + ksi[obs_idx, 0]*lambdas_3[2]
    m9 = tau[9] + ksi[obs_idx, 1]*lambdas_4[0]
    m10 = tau[10] + ksi[obs_idx, 1]*lambdas_4[1]
    m11 = tau[11] + ksi[obs_idx, 1]*lambdas_4[2]
    m12 = tau[12] + regression*lambdas_5[0]
    m13 = tau[13] + regression*lambdas_5[1]
    m14 = tau[14] + regression*lambdas_5[2]
    
    mu = pm.Deterministic('mu', pm.math.stack([m0, m1, m2, m3, m4, m5, m6, m7,
                                              m8, m9, m10, m11, m12, m13, m14]).T)
    _  = pm.Normal('likelihood', mu, Psi, observed=df[drivers].values)

    idata = pm.sample(10_000, chains=4, nuts_sampler='numpyro', target_accept=.99, tune=2000,
                      idata_kwargs={"log_likelihood": True}, random_seed=110)
    idata.extend(pm.sample_posterior_predictive(idata))

    return model, idata


model2, idata2 = make_indirect_sem(priors={'eta': 2, 'lambda': [1, 1]})



```

There is quite a bit of extra structure now in our model. This structure articulates the path-dependence of the self-efficacy constructs on the support constructs. We've specified these as separate regressions with coefficient values for each of the support constructs, but additionally we need to ensure there is a correlation between the implied self-efficacy scores so we've wrapped the regression equations in two normal distributions with correlated residual terms. In this manner we preserve the multivariate relationships and allow the model to place weight on this prior if there is a strong co-determination effect. It's perhaps easier to see in a picture than think through the code directly:

![Structural Equation Models](sem_model.svg)The main point to emphasize here is the expressive nature of the modelling paradigm. Our ability to construct and estimate different chains of dependence allows us to test and evaluate the direct and indirect effects due to the different "drivers" of life-satisfaction.

As before we can still recover posterior predictive check to evaluate granular level performance against the observed data points.

```{python fig.width=10, fig.height=15}
make_ppc(idata2)

```

But additionally we can pull out the regression summary coefficients and report on the direct and indirect effects of our constructs

```{python}

summary_df = az.summary(idata2, var_names=['beta_r', 'beta_r2'])

def calculate_effects(summary_df, var='SUP_P'):
    #Indirect Paths
    ## VAR -> SE_SOC ->LS
    indirect_parent_soc = summary_df.loc[f'beta_r[{var}->SE_SOC]']['mean']*summary_df.loc['beta_r2[SE_SOCIAL]']['mean']

    ## VAR -> SE_SOC ->LS
    indirect_parent_acad = summary_df.loc[f'beta_r[{var}->SE_ACAD]']['mean']*summary_df.loc['beta_r2[SE_ACAD]']['mean']

    ## Total Indirect Effects
    total_indirect = indirect_parent_soc + indirect_parent_acad

    ## Total Effects
    total_effect = total_indirect + summary_df.loc[f'beta_r2[{var}]']['mean']

    return pd.DataFrame([[indirect_parent_soc, indirect_parent_acad, total_indirect, total_effect]], 
                columns=[f'{var} -> SE_SOC ->LS', f'{var} -> SE_ACAD ->LS', f'Total Indirect Effects {var}', f'Total Effects {var}']
                )

indirect_p = calculate_effects(summary_df, 'SUP_P')
indirect_f = calculate_effects(summary_df, 'SUP_F')

residuals_posterior_cov = get_posterior_resids(idata2, 500)
residuals_posterior_corr = get_posterior_resids(idata2, 500, 'corr')

```

The regression effects seem well sampled and show the strength of relationships between social self-efficacy scores and reported life-satisfaction.

```{r}

py$summary_df |> kable( caption= "Regression Coefficients Amongst Latent Factors", digits=2) |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")

```

But now we can also pull out estimates of the indirect and total effects of parental and peer support on the outcome of life-satisfaction using the multiplicative path-tracing rules.

```{r}

py$indirect_p |> kable( caption= "Total and Indirect Effects: Parental Support", digits=2) |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")

py$indirect_f |> kable( caption= "Total and Indirect Effects: Friend Support", digits=4) |> kable_styling() |>  kable_classic(full_width = F, html_font = "Cambria")

```

Note that we've defined these effects as point estimates on the mean realizations of the regression coefficients. But we could have defined these quantities in the model context and sampled the posterior distribution too. However, the model was already complex enough that we kept it simpler for the clarity of exposition.

Finally we can plot the residual variance-covariance for the Bayesian estimate of Structural equation model we hypothesized.

```{r fig.width=10}

plot_heatmap(py$residuals_posterior_cov, "Residuals of the Sample Covariances and Model Implied Covariances", "A Visual Check of Bayesian Structural Model fit")

```

The overall impression seems quite reasonable, but **notably** distinct from the fit of the simpler measurement model. In this way the flexibility of the Bayesian estimation strategy is not as constrained as the MLE variance-covariance estimation strategy and we can learn of meaningful interactions in a richer more theoretically compelling model while still calibrating against the observed data. This is borne out global model comparisons too.

```{python fig.width=10, results='hide'}

compare_df = az.compare({'Measurement Model': idata, 'Structural Model': idata2});
az.plot_compare(compare_df);
plt.show()

```

The structural model is marginally worse by measures of global fit to the data, but this summary skips over the variety of questions we can answer with this new structure. The broad fidelity to observed data seen in the posterior predictive checks and the variance covariance residuals suggests that we ought to be willing to take this hit to global performance if we can answer questions left unanswered by the measurement model.

## Conclusion: [Build the Model with Lasers!](https://quantitudepod.org/s4e06-model-building/)

At the outset of this analysis we stated the hypothetical structure of interest. This suggests a pure confirmatory project, but in practice much of the feasibility of this analysis is path dependent and constrained by the viability of the various model architectures with respect to the data. It's easy to tell the story of increasingly sophisticated models, more powerful, more insightful inferential claims. Yet, this narrative is compelling only in so far as there is a justifiable sequence of steps through the ascension of model complexity. The increase in complexity needs to be off-set by a rationale at each step.

To recap we have worked through a series of simple regression models seeking to tease out the weighted importance of various factors on the outcomes of life-satisfaction. These models highlighted fairly consistently the relative importance of metrics related to parental support and social self-efficacy. We also saw how there was a significant modification effect for the interaction term. These are all suggestive that we've picked out a meaningful set of metrics and which ought to support inferences about the phenomena of interest. But how do we parcel those metrics in such a way to support clean and compelling statements about the influence of each of reported life-satisfaction? Here we sought to leverage CFA and SEM models to clarify the structure of this influence and the particular pathways by which parental support drives these outcomes.

These latter models were then re-articulated as a species of Bayesian hierarchical models which aim to induce conditional independence amongst the thematically similar metrics by grouping each under a common factor. Which is to say, we assume that the joint distribution of outcomes is exchangeable and we can fit a conditional mixture to represent that joint distribution. We then showed how these conditional structures can be further adapted to answer questions about direct and indirect causation that bear precisely on the hypothetical structure we declared to be our target at the outset. Yet it's not enough to fit a model and claim to be done. You have to proffer a defense that the model estimated is both plausible and recovers the observed data well. The very process of iterative Bayesian model development encodes these checks and balances. Iterative model refinement is no guide to which questions should be asked of a model, yet questions occur as we explore the posterior distribution. Inspiration strikes when you have samples to hand and can test the implications of some idle thought. Perhaps some parameterisation yields poor model fit and the re-parameterisation (a shift in some focal parameter's prior) recovers better performance and prompts a new theoretical lens on your problem. While not a panacea to all forms of statistical misstep, this [workflow](https://arxiv.org/pdf/2011.01808) is a positive, rich and rewarding methodological practice. The iterative model workflow is a natural seeking of the "right" conditionalisation to inform our decisions. In the end we make an inference to the best explanation by argument that covers theoretical nuance, computational burden and points of practical compromise. But we are making an argument - Yes, we've walked down the garden of forking garden paths, but our choices were deliberate and we suffer no regret.
